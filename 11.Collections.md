## Collections In JAVA
Collections in Java refer to a framework and architecture provided by the Java Collections Framework (JCF) to manipulate and store groups of objects. The JCF provides a set of interfaces, implementations, and algorithms to work with collections of objects efficiently. Here, I'll describe the core collection interfaces and some commonly used classes in the Java Collections Framework along with their methods and dependencies.

### Core Collection Interfaces:

1. **Collection\<E\>**:
   - Represents a group of objects, known as elements.
   - Key methods: `add(E e)`, `remove(Object obj)`, `size()`, `iterator()`.
   - Implementations: `List`, `Set`, `Queue`.

2. **List\<E\>**:
   - Represents an ordered collection (sequence) of elements.
   - Allows duplicate elements.
   - Key methods: `add(E e)`, `remove(Object obj)`, `get(int index)`, `set(int index, E element)`, `indexOf(Object obj)`, `size()`.
   - Implementations: `ArrayList`, `LinkedList`, `Vector`, `Stack`.

3. **Set\<E\>**:
   - Represents a collection that contains no duplicate elements.
   - Key methods: `add(E e)`, `remove(Object obj)`, `contains(Object obj)`, `size()`.
   - Implementations: `HashSet`, `LinkedHashSet`, `TreeSet`.

4. **Queue\<E\>**:
   - Represents a collection designed for holding elements prior to processing.
   - Typically orders elements in a FIFO (First-In-First-Out) manner.
   - Key methods: `add(E e)`, `remove()`, `peek()`, `size()`.
   - Implementations: `LinkedList`, `PriorityQueue`.

5. **Map\<K, V\>**:
   - Represents a collection of key-value pairs, where each key is associated with a single value.
   - Key methods: `put(K key, V value)`, `get(Object key)`, `remove(Object key)`, `containsKey(Object key)`, `containsValue(Object value)`, `size()`.
   - Implementations: `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`.

### Commonly Used Collection Classes:

1. **ArrayList**:
   - Implements the `List interface` using a dynamic array.
   - Provides fast random access and fast iteration.
   - Example:

   ```java
   List<String> list = new ArrayList<>();
   list.add("Apple");
   list.add("Banana");
   list.add("Orange");
   ```

2. **HashSet**:
   - Implements the `Set interface` using a hash table.
   - Does not guarantee the order of elements (`Unordered`).
   - Does not allow duplicate elements.
   - Example:

   ```java
   Set<Integer> set = new HashSet<>();
   set.add(1);
   set.add(2);
   set.add(3);
   ```

3. **LinkedList**:
   - Implements the `List and Queue interfaces` using a doubly-linked list.
   - Provides efficient insertion and deletion operations.
   - Example:

   ```java
   List<String> list = new LinkedList<>();
   list.add("Apple");
   list.add("Banana");
   list.add("Orange");
   ```

4. **HashMap**:
   - Implements the `Map interface` using a hash table.
   - Allows null keys and values.
   - Example:

   ```java
   Map<String, Integer> map = new HashMap<>();
   map.put("one", 1);
   map.put("two", 2);
   map.put("three", 3);
   ```

5. **TreeSet**:
   - Implements the `Set interface` using a `red-black tree`.
   - Guarantees the elements to be in sorted order.
   - Example:

   ```java
   Set<Integer> set = new TreeSet<>();
   set.add(3);
   set.add(1);
   set.add(2);
   ```

These are just a few examples of commonly used collection classes in Java. Each collection class has its own characteristics, performance characteristics, and use cases. Understanding these classes and their methods is essential for effective Java programming.


## Herarchical Of Collection Frameowork
hierarchical structure of the Java Collections Framework:

```
Iterable Interfacee
│
Collection Interface
│
├── List Interface
│   ├── ArrayList class
│   ├── LinkedList class
│   ├── Vector class (Lagacy)
│   └── Stack class (Lagacy)
│
├── Set Interface
│   ├── Sorted Set Interface
|   |   └── TreeSet Class
|   |
│   ├── HashSet class
│   └── LinkedHashSet class (Lagacy)
│
└── Queue Interface
    ├── PriorityQueue class
    |
    └── Deque Inyterface
        └── ArrayDeque class



Map Interface (Different From Collection Interface)
│
├── SortedMap Interface
│   └── NavigableMap Interface
│       └── TreeMap class
│
└── ConcurrentMap Interface
    ├── HashMap class
    ├── LinkedHashMap Class
    ├── HashTable class (Lagacy)
    ├── ConcurrentHashMap
    └── ConcurrentSkipListMap
```
This hierarchical structure represents the relationships between interfaces and their implementations in the Java Collections Framework. Each interface may have multiple implementations providing different functionalities while adhering to the contracts defined by their respective interfaces.


## Iterabel Interface Methods
The `Iterable` interface in Java is the root interface for all collection classes. It provides a single method, `iterator()`, which returns an iterator over the elements of the collection. Here's the method declared in the `Iterable` interface:

1. **Iteration**:
   - `Iterator<T> iterator()`: Returns an iterator over elements of type `T`.

The `Iterator` interface, returned by the `iterator()` method, provides a way to iterate over a collection's elements sequentially. It includes the following methods:

- `boolean hasNext()`: Returns `true` if the iteration has more elements.
- `T next()`: Returns the next element in the iteration.
- `void remove()`: Removes from the underlying collection the last element returned by this iterator (optional operation).

The `Iterable` interface allows any class that implements it to be used in the enhanced for-loop syntax (foreach loop) introduced in Java 5. This loop simplifies the process of iterating over elements of a collection by hiding the details of using an iterator directly. 

Here's an example of using the `Iterable` interface with the foreach loop:

```java
Iterable<String> iterable = new ArrayList<>();
iterable.add("Hello");
iterable.add("World");

for (String s : iterable) {
    System.out.println(s);
}
```

In this example, the `ArrayList` implements the `Iterable` interface, allowing it to be used in the foreach loop to iterate over its elements.



## Collection Interface Methods
The `Collection` interface in Java defines a set of methods for working with collections of objects. Here are some of the most commonly used methods declared in the `Collection` interface:

1. **Modification Operations**:
   - `boolean add(E e)`: Adds the specified element to the collection if it is not already present.
   - `boolean remove(Object o)`: Removes a single instance of the specified element from this collection, if it is present.
   - `boolean addAll(Collection<? extends E> c)`: Adds all of the elements in the specified collection to this collection.

2. **Bulk Operations**:
   - `boolean containsAll(Collection<?> c)`: Returns `true` if this collection contains all of the elements in the specified collection.
   - `boolean removeAll(Collection<?> c)`: Removes all of this collection's elements that are also contained in the specified collection.
   - `boolean retainAll(Collection<?> c)`: Retains only the elements in this collection that are contained in the specified collection.

3. **Query Operations**:
   - `int size()`: Returns the number of elements in this collection.
   - `boolean isEmpty()`: Returns `true` if this collection contains no elements.
   - `boolean contains(Object o)`: Returns `true` if this collection contains the specified element.

4. **Array Operations**:
   - `Object[] toArray()`: Returns an array containing all of the elements in this collection.
   - `<T> T[] toArray(T[] a)`: Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array.

5. **Stream Operations** (introduced in Java 8):
   - `default Stream<E> stream()`: Returns a sequential `Stream` with this collection as its source.
   - `default Stream<E> parallelStream()`: Returns a possibly parallel `Stream` with this collection as its source.

These methods provide basic functionality for manipulating and querying collections in Java. Implementations of the `Collection` interface, such as `ArrayList`, `HashSet`, etc., provide concrete implementations for these methods according to their specific data structures and requirements.

#### NOTE:- Inherits All The Methods Of Iterable Interface


## List Interface Methods 
The `List` interface in Java extends the `Collection` interface and represents an ordered collection of elements. Here are the methods declared in the `List` interface:

1. **Index-based Access**:
   - `E get(int index)`: Returns the element at the specified position in this list.
   - `E set(int index, E element)`: Replaces the element at the specified position in this list with the specified element.
   - `void add(int index, E element)`: Inserts the specified element at the specified position in this list.
   - `E remove(int index)`: Removes the element at the specified position in this list and returns it.
   
2. **Search Operations**:
   - `int indexOf(Object o)`: Returns the index of the first occurrence of the specified element in this list, or -1 if the list does not contain the element.
   - `int lastIndexOf(Object o)`: Returns the index of the last occurrence of the specified element in this list, or -1 if the list does not contain the element.

3. **List Iteration**:
   - `ListIterator<E> listIterator()`: Returns a list iterator over the elements in this list (in proper sequence).
   - `ListIterator<E> listIterator(int index)`: Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list.

4. **Sublist Operations**:
   - `List<E> subList(int fromIndex, int toIndex)`: Returns a view of the portion of this list between the specified `fromIndex`, inclusive, and `toIndex`, exclusive.

These methods provide functionality for accessing, manipulating, and searching elements within a list. Implementations of the `List` interface, such as `ArrayList`, `LinkedList`, etc., provide concrete implementations for these methods according to their specific data structures and requirements.


#### NOTE:- Inherits All The Methods Of Iterable and Collection Interface

## Set Interface Methods
The `Set` interface in Java represents a collection of unique elements. It extends the `Collection` interface and adds the behavior of not allowing duplicate elements. Here are the methods declared in the `Set` interface:

1. **Modification Operations**:
   - `boolean add(E e)`: Adds the specified element to the set if it is not already present.
   - `boolean remove(Object o)`: Removes the specified element from the set if it is present.
   - `boolean addAll(Collection<? extends E> c)`: Adds all of the elements in the specified collection to the set if they're not already present.

2. **Bulk Operations**:
   - `boolean containsAll(Collection<?> c)`: Returns `true` if the set contains all of the elements in the specified collection.
   - `boolean removeAll(Collection<?> c)`: Removes from the set all of its elements that are contained in the specified collection.
   - `boolean retainAll(Collection<?> c)`: Retains only the elements in the set that are contained in the specified collection.

3. **Comparison Operations**:
   - `boolean equals(Object o)`: Compares the specified object with this set for equality.
   - `int hashCode()`: Returns the hash code value for the set.

4. **Query Operations**:
   - `int size()`: Returns the number of elements in the set.
   - `boolean isEmpty()`: Returns `true` if the set contains no elements.
   - `boolean contains(Object o)`: Returns `true` if the set contains the specified element.

5. **Array Operations**:
   - `Object[] toArray()`: Returns an array containing all of the elements in the set.
   - `<T> T[] toArray(T[] a)`: Returns an array containing all of the elements in the set; the runtime type of the returned array is that of the specified array.

6. **Stream Operations** (introduced in Java 8):
   - `default Stream<E> stream()`: Returns a sequential `Stream` with this collection as its source.
   - `default Stream<E> parallelStream()`: Returns a possibly parallel `Stream` with this collection as its source.

These methods provide functionality for manipulating and querying sets in Java. Implementations of the `Set` interface, such as `HashSet`, `TreeSet`, etc., provide concrete implementations for these methods according to their specific data structures and requirements.

## Deque Interface Methods
The `Deque` interface in Java represents a double-ended queue, which supports insertion and removal of elements at both ends. It stands for "double-ended queue." The `Deque` interface extends the `Queue` interface and provides additional methods for element insertion, retrieval, and removal at both ends of the queue. Here are the methods declared in the `Deque` interface:

1. **Insertion Operations**:
   - `void addFirst(E e)`: Inserts the specified element at the front of this deque.
   - `void addLast(E e)`: Inserts the specified element at the end of this deque.
   - `boolean offerFirst(E e)`: Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions.
   - `boolean offerLast(E e)`: Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions.

2. **Removal Operations**:
   - `E removeFirst()`: Retrieves and removes the first element of this deque.
   - `E removeLast()`: Retrieves and removes the last element of this deque.
   - `E pollFirst()`: Retrieves and removes the first element of this deque, or returns `null` if this deque is empty.
   - `E pollLast()`: Retrieves and removes the last element of this deque, or returns `null` if this deque is empty.

3. **Access Operations**:
   - `E getFirst()`: Retrieves, but does not remove, the first element of this deque.
   - `E getLast()`: Retrieves, but does not remove, the last element of this deque.
   - `E peekFirst()`: Retrieves, but does not remove, the first element of this deque, or returns `null` if this deque is empty.
   - `E peekLast()`: Retrieves, but does not remove, the last element of this deque, or returns `null` if this deque is empty.

4. **Queue Methods** (inherited from the `Queue` interface):
   - `void add(E e)`: Inserts the specified element into the queue represented by this deque.
   - `boolean offer(E e)`: Inserts the specified element into the queue represented by this deque if it is possible to do so immediately without violating capacity restrictions.
   - `E remove()`: Retrieves and removes the head of the queue represented by this deque.
   - `E poll()`: Retrieves and removes the head of the queue represented by this deque, or returns `null` if this deque is empty.
   - `E element()`: Retrieves, but does not remove, the head of the queue represented by this deque.
   - `E peek()`: Retrieves, but does not remove, the head of the queue represented by this deque, or returns `null` if this deque is empty.

These methods provide functionality for manipulating and querying double-ended queues in Java. Implementations of the `Deque` interface, such as `ArrayDeque`, `LinkedList`, etc., provide concrete implementations for these methods according to their specific data structures and requirements.

## ArrayList And Iterator
Certainly! An `ArrayList` in Java is a part of the `java.util` package and is a resizable array implementation of the `List` interface. It dynamically grows its size when new elements are added and shrinks when elements are removed. Here's how you typically use `ArrayList` along with an `Iterator`:

1. **Creating an ArrayList**:
   You create an `ArrayList` instance with a specific type of elements.

```java
ArrayList<String> arrayList = new ArrayList<>();
ArrayList<String> arrayList = new ArrayList<>(List.of(1, 3, 4, 5));
```

2. **Adding elements to ArrayList**:
   You can add elements to the `ArrayList` using the `add()` method.

```java
arrayList.add("Element 1");
arrayList.add("Element 2");
arrayList.add("Element 3");
```

3. **Using Iterator with ArrayList**:
   You can obtain an `Iterator` instance from the `ArrayList` and use it to iterate over the elements.

```java
Iterator<String> iterator = arrayList.iterator();
while(iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```

4. **Removing elements during iteration**:
   You can also remove elements from the `ArrayList` while iterating using the `remove()` method of the `Iterator`.

```java
Iterator<String> iterator = arrayList.iterator();
while(iterator.hasNext()) {
    String element = iterator.next();
    if (element.equals("Element 2")) {
        iterator.remove(); // Removes "Element 2" from the ArrayList
    }
}
```

5. **Using enhanced for-loop**:
   Alternatively, you can use a for-each loop to iterate over the elements of the `ArrayList`.

```java
for (String element : arrayList) {
    System.out.println(element);
}
```

6. **Clearing the ArrayList**:
   You can clear all elements of the `ArrayList` using the `clear()` method.

```java
arrayList.clear();
```

`ArrayList` provides efficient random access and is a good choice when you frequently need to access elements by their index. It also allows duplicates and maintains the insertion order of elements. When iterating over elements, using an `Iterator` provides a safe way to traverse the collection and perform modifications if needed.

## Linked List Methods
Certainly! A `LinkedList` in Java is a linear data structure consisting of a sequence of elements where each element points to the next element in the sequence. It implements the `List` interface and provides methods for adding, removing, and manipulating elements. Here's an overview of `LinkedList` and its methods:

1. **Creating a LinkedList**:
   You can create a `LinkedList` instance by simply instantiating it:

   ```java
   LinkedList<String> linkedList = new LinkedList<>();
   ```

2. **Adding Elements**:
   - `void addFirst(E e)`: Inserts the specified element at the beginning of the list.
   - `void addLast(E e)`: Appends the specified element to the end of the list.
   - `boolean add(E e)`: Appends the specified element to the end of the list (equivalent to `addLast`).
   - `void add(int index, E element)`: Inserts the specified element at the specified position in the list.

3. **Removing Elements**:
   - `E removeFirst()`: Retrieves and removes the first element of the list.
   - `E removeLast()`: Retrieves and removes the last element of the list.
   - `boolean remove(Object o)`: Removes the first occurrence of the specified element from the list.
   - `E remove(int index)`: Removes the element at the specified position in the list.

4. **Accessing Elements**:
   - `E getFirst()`: Retrieves the first element of the list without removing it.
   - `E getLast()`: Retrieves the last element of the list without removing it.
   - `E get(int index)`: Returns the element at the specified position in the list.

5. **Size and Clearing**:
   - `int size()`: Returns the number of elements in the list.
   - `boolean isEmpty()`: Returns `true` if the list contains no elements.
   - `void clear()`: Removes all elements from the list.

6. **Iteration**:
   - `Iterator<E> iterator()`: Returns an iterator over the elements in the list.
   - `forEach(Consumer<? super E> action)`: Performs the given action for each element of the list until all elements have been processed or the action throws an exception.

**Example**:
```java
LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("Element 1");
linkedList.add("Element 2");
linkedList.add("Element 3");

// Iterating over the elements using enhanced for-loop
for (String element : linkedList) {
    System.out.println(element);
}

// Iterating over the elements using Iterator
Iterator<String> iterator = linkedList.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```

In this example, we create a `LinkedList`, add elements to it, and then iterate over the elements using both the enhanced for-loop and an explicit `Iterator`. This demonstrates two common ways to iterate over a `LinkedList`.


## ArrayDeque 
`ArrayDeque` in Java is a resizable-array implementation of the `Deque` interface. It provides methods for adding, removing, and manipulating elements at both ends of the deque. Here's an overview of `ArrayDeque` and its methods:

1. **Creating an ArrayDeque**:
   You can create an `ArrayDeque` instance by simply instantiating it:

   ```java
   ArrayDeque<String> arrayDeque = new ArrayDeque<>();
   ```

2. **Adding Elements**:
   - `void addFirst(E e)`: Inserts the specified element at the front of the deque.
   - `void addLast(E e)`: Inserts the specified element at the end of the deque.
   - `boolean offerFirst(E e)`: Inserts the specified element at the front of the deque if it is possible to do so immediately without violating capacity restrictions.
   - `boolean offerLast(E e)`: Inserts the specified element at the end of the deque if it is possible to do so immediately without violating capacity restrictions.
   - `boolean add(E e)`: Adds the specified element to the end of the deque (equivalent to `addLast`).

3. **Removing Elements**:
   - `E removeFirst()`: Retrieves and removes the first element of the deque.
   - `E removeLast()`: Retrieves and removes the last element of the deque.
   - `boolean removeFirstOccurrence(Object o)`: Removes the first occurrence of the specified element from the deque.
   - `boolean removeLastOccurrence(Object o)`: Removes the last occurrence of the specified element from the deque.
   - `E pollFirst()`: Retrieves and removes the first element of the deque, or returns `null` if the deque is empty.
   - `E pollLast()`: Retrieves and removes the last element of the deque, or returns `null` if the deque is empty.

4. **Accessing Elements**:
   - `E getFirst()`: Retrieves the first element of the deque without removing it.
   - `E getLast()`: Retrieves the last element of the deque without removing it.
   - `E peekFirst()`: Retrieves the first element of the deque without removing it, or returns `null` if the deque is empty.
   - `E peekLast()`: Retrieves the last element of the deque without removing it, or returns `null` if the deque is empty.

5. **Size and Clearing**:
   - `int size()`: Returns the number of elements in the deque.
   - `boolean isEmpty()`: Returns `true` if the deque contains no elements.
   - `void clear()`: Removes all elements from the deque.

6. **Iteration**:
   - `Iterator<E> iterator()`: Returns an iterator over the elements in the deque.
   - `forEach(Consumer<? super E> action)`: Performs the given action for each element of the deque until all elements have been processed or the action throws an exception.

**Example**:
```java
ArrayDeque<String> arrayDeque = new ArrayDeque<>();
arrayDeque.addFirst("First");
arrayDeque.addLast("Last");

// Iterating over the elements using enhanced for-loop
for (String element : arrayDeque) {
    System.out.println(element);
}

// Iterating over the elements using Iterator
Iterator<String> iterator = arrayDeque.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```

In this example, we create an `ArrayDeque`, add elements to it, and then iterate over the elements using both the enhanced for-loop and an explicit `Iterator`. This demonstrates two common ways to iterate over an `ArrayDeque`.

## PriorityQueue
`PriorityQueue` in Java is an implementation of the `Queue` interface that provides a priority ordering for its elements. The elements are ordered according to their natural ordering or by a specified comparator. Here's an overview of `PriorityQueue` and its methods:

1. **Creating a PriorityQueue**:
   You can create a `PriorityQueue` instance by simply instantiating it. Optionally, you can provide a comparator to define the priority order.

   ```java
   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
   ```

   or with a custom comparator:

   ```java
   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(Comparator.reverseOrder());
   ```

2. **Adding Elements**:
   - `boolean add(E e)`: Inserts the specified element into the priority queue.
   - `boolean offer(E e)`: Inserts the specified element into the priority queue.

3. **Removing Elements**:
   - `E remove()`: Retrieves and removes the head of the priority queue (the highest priority element).
   - `E poll()`: Retrieves and removes the head of the priority queue, or returns `null` if the priority queue is empty.

4. **Accessing Elements**:
   - `E peek()`: Retrieves, but does not remove, the head of the priority queue, or returns `null` if the priority queue is empty.

5. **Size and Clearing**:
   - `int size()`: Returns the number of elements in the priority queue.
   - `boolean isEmpty()`: Returns `true` if the priority queue contains no elements.
   - `void clear()`: Removes all elements from the priority queue.

6. **Iteration**:
   `PriorityQueue` does not provide direct iteration over its elements in a specified order. However, you can iterate over its elements by removing elements from the queue until it's empty.

**Example**:
```java
PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
priorityQueue.offer(3);
priorityQueue.offer(1);
priorityQueue.offer(2);

// Iterating over the elements by polling them from the queue
while (!priorityQueue.isEmpty()) {
    System.out.println(priorityQueue.poll());
}
```

In this example, we create a `PriorityQueue`, add elements to it, and then iterate over the elements by continuously removing elements from the queue until it's empty. This demonstrates how you can iterate over the elements of a `PriorityQueue`.

## Hashing Techniques
Hashing techniques in programming are used to map data of arbitrary size to fixed-size values, typically integers, known as hash codes. These hash codes are used for various purposes, such as indexing data structures like hash tables, ensuring data integrity in cryptographic applications, and quickly searching for data.

Here's an overview of common hashing techniques:

1. **Normal Hashing**:
   - **Division Method**: Involves taking the remainder of the key divided by the size of the hash table. It's simple but may result in clustering when poorly chosen.
   - **Multiplication Method**: Involves multiplying the key by a constant, extracting a fraction part, and multiplying it by the size of the hash table. It provides better distribution compared to the division method.
   - **Folding Method**: Involves dividing the key into equal-sized parts (of the size of the hash table), adding them up, and taking the remainder when divided by the size of the hash table.

2. **Collision Resolution**:
   - **Chaining**: Involves maintaining a linked list of elements for each hash table slot. Collisions are resolved by appending elements to the linked list.
   - **Open Addressing**: Involves finding an alternative location in the hash table when a collision occurs. Techniques include linear probing, quadratic probing, and double hashing.

3. **Optimized Hashing**:
   - **Universal Hashing**: Uses a family of hash functions from which a function is randomly chosen. This reduces the likelihood of collision and provides better average-case performance.
   - **Perfect Hashing**: Achieves minimal or zero collisions by constructing a hash function that maps each key to a unique hash code. It's suitable for situations where the keys are known in advance.
   - **Cryptographic Hashing**: Involves using cryptographic hash functions like SHA-256 or MD5 to generate hash codes. These functions are designed to be collision-resistant and provide a high level of security.

4. **Additional Techniques**:
   - **Consistent Hashing**: Used in distributed systems to minimize rehashing when the number of hash slots changes. It's particularly useful for load balancing and caching scenarios.
   - **Bloom Filters**: Probabilistic data structures that efficiently represent a set and allow for membership queries. They use multiple hash functions to minimize false positives.

Choosing the right hashing technique depends on factors such as the characteristics of the data, performance requirements, and constraints of the application environment. Additionally, collision resolution strategies play a crucial role in the efficiency and effectiveness of hash-based data structures.

## HashSet
`HashSet` in Java is an implementation of the `Set` interface that uses a hash table for storage. It does not allow duplicate elements and does not guarantee the order of elements. Here's an overview of `HashSet` and its methods:

1. **Creating a HashSet**:
   You can create a `HashSet` instance by simply instantiating it:

   ```java
   HashSet<String> hashSet = new HashSet<>();
   ```

2. **Adding Elements**:
   - `boolean add(E e)`: Adds the specified element to the set if it is not already present.

3. **Removing Elements**:
   - `boolean remove(Object o)`: Removes the specified element from the set if it is present.
   - `void clear()`: Removes all elements from the set.

4. **Accessing Elements**:
   - `boolean contains(Object o)`: Returns `true` if the set contains the specified element.
   - `int size()`: Returns the number of elements in the set.
   - `boolean isEmpty()`: Returns `true` if the set contains no elements.

5. **Iteration**:
   - `Iterator<E> iterator()`: Returns an iterator over the elements in the set.
   - `forEach(Consumer<? super E> action)`: Performs the given action for each element of the set until all elements have been processed or the action throws an exception.

**Example**:
```java
HashSet<String> hashSet = new HashSet<>();
hashSet.add("Element 1");
hashSet.add("Element 2");
hashSet.add("Element 3");

// Iterating over the elements using enhanced for-loop
for (String element : hashSet) {
    System.out.println(element);
}

// Iterating over the elements using Iterator
Iterator<String> iterator = hashSet.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```

In this example, we create a `HashSet`, add elements to it, and then iterate over the elements using both the enhanced for-loop and an explicit `Iterator`. This demonstrates two common ways to iterate over a `HashSet`.

## TreeSet
`TreeSet` in Java is an implementation of the `SortedSet` interface, which uses a red-black tree for storage. It maintains elements in sorted order and does not allow duplicates. Here's an overview of `TreeSet` and its methods:

1. **Creating a TreeSet**:
   You can create a `TreeSet` instance by simply instantiating it. Optionally, you can provide a comparator to define the sorting order.

   ```java
   TreeSet<Integer> treeSet = new TreeSet<>();
   ```

   or with a custom comparator:

   ```java
   TreeSet<Integer> treeSet = new TreeSet<>(Comparator.reverseOrder());
   ```

2. **Adding Elements**:
   - `boolean add(E e)`: Adds the specified element to the set if it is not already present.
   - `boolean addAll(Collection<? extends E> c)`: Adds all of the elements in the specified collection to the set.

3. **Removing Elements**:
   - `boolean remove(Object o)`: Removes the specified element from the set if it is present.
   - `void clear()`: Removes all elements from the set.

4. **Accessing Elements**:
   - `E first()`: Returns the first (lowest) element currently in the set.
   - `E last()`: Returns the last (highest) element currently in the set.
   - `E higher(E e)`: Returns the least element in the set strictly greater than the given element, or `null` if there is no such element.
   - `E lower(E e)`: Returns the greatest element in the set strictly less than the given element, or `null` if there is no such element.

5. **Size and Clearing**:
   - `int size()`: Returns the number of elements in the set.
   - `boolean isEmpty()`: Returns `true` if the set contains no elements.

6. **Iteration**:
   - `Iterator<E> iterator()`: Returns an iterator over the elements in the set.
   - `forEach(Consumer<? super E> action)`: Performs the given action for each element of the set until all elements have been processed or the action throws an exception.

**Example**:
```java
TreeSet<Integer> treeSet = new TreeSet<>();
treeSet.add(3);
treeSet.add(1);
treeSet.add(2);

// Iterating over the elements using enhanced for-loop
for (Integer element : treeSet) {
    System.out.println(element);
}

// Iterating over the elements using Iterator
Iterator<Integer> iterator = treeSet.iterator();
while (iterator.hasNext()) {
    Integer element = iterator.next();
    System.out.println(element);
}
```

In this example, we create a `TreeSet`, add elements to it, and then iterate over the elements using both the enhanced for-loop and an explicit `Iterator`. This demonstrates two common ways to iterate over a `TreeSet`.


## Comparable Interface In JAVA
The `Comparable` interface in Java is used to define the natural ordering of objects of a class. It contains a single method, `compareTo()`, which compares the current object with another object. The `compareTo()` method returns a negative integer, zero, or a positive integer depending on whether the current object is less than, equal to, or greater than the specified object.

Here's the declaration of the `Comparable` interface:

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

When a class implements the `Comparable` interface, it means that objects of that class can be compared to each other based on a natural ordering. This ordering is typically defined by the class itself.

**Usage**:
Consider a simple class `Person` that represents individuals with a name and age:

```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // Constructor, getters, and setters

    @Override
    public int compareTo(Person otherPerson) {
        // Compare based on age
        return Integer.compare(this.age, otherPerson.age);
    }
}
```

In this example, the `Person` class implements the `Comparable<Person>` interface. The `compareTo()` method compares two `Person` objects based on their age. If you want to sort a collection of `Person` objects by age, you can simply use `Collections.sort()` or `Arrays.sort()` because `Person` objects know how to compare themselves based on their age.

Here's how you can use `Comparable` to sort a list of `Person` objects:

```java
List<Person> personList = new ArrayList<>();
personList.add(new Person("Alice", 25));
personList.add(new Person("Bob", 30));
personList.add(new Person("Charlie", 20));

Collections.sort(personList); // Sorts the list based on age

for (Person person : personList) {
    System.out.println(person.getName() + " - " + person.getAge());
}
```

This will output:

```
Charlie - 20
Alice - 25
Bob - 30
```

As you can see, the `personList` is sorted based on the age of the `Person` objects, thanks to the implementation of the `compareTo()` method in the `Person` class.

Another Example:

```java
import java.util.*;

class Point implements Comparable
{
    int x;
    int y;
    public Point(int x,int y)
    {
        this.x=x;
        this.y=y;
    }
    public String toString()
    {
        return "x="+x+"y="+y;
    }
    public int compareTo(Object o)
    {
        Point p=(Point)o;
        if(this.x<p.x)
            return -1;
        else if(this.x>p.x)
            return 1;
        else
        {
        if(this.y<p.y) 
            return -1;
        else if(this.y>p.y)
            return 1;
        else 
            return 0;
        }
    }
}

public class SetDemo2 {

    public static void main(String[] args) {
        
        TreeSet<Point> ts=new TreeSet<>();
        
        ts.add(new Point(1,1));
        ts.add(new Point(5,5));
        ts.add(new Point(5,2));
        
        System.out.println(ts);
    }
    
}
```


## HashMap In JAVA
`HashMap` in Java is a data structure that implements the `Map` interface and provides key-value pairs storage. It uses a hash table for indexing and allows for efficient retrieval and manipulation of elements. Here's an overview of `HashMap` and its methods:

1. **Creating a HashMap**:
   You can create a `HashMap` instance by simply instantiating it:

   ```java
   HashMap<String, Integer> hashMap = new HashMap<>();
   ```

2. **Adding and Updating Elements**:
   - `V put(K key, V value)`: Associates the specified value with the specified key in the map.
   - `void putAll(Map<? extends K, ? extends V> m)`: Copies all of the mappings from the specified map to this map.

3. **Retrieving Elements**:
   - `V get(Object key)`: Returns the value to which the specified key is mapped, or `null` if this map contains no mapping for the key.
   - `boolean containsKey(Object key)`: Returns `true` if this map contains a mapping for the specified key.

4. **Removing Elements**:
   - `V remove(Object key)`: Removes the mapping for the specified key from this map if present.
   - `void clear()`: Removes all of the mappings from this map.

5. **Size and Checking Empty**:
   - `int size()`: Returns the number of key-value mappings in this map.
   - `boolean isEmpty()`: Returns `true` if this map contains no key-value mappings.

6. **Iteration**:
   - `Set<K> keySet()`: Returns a set view of the keys contained in this map.
   - `Collection<V> values()`: Returns a collection view of the values contained in this map.
   - `Set<Map.Entry<K, V>> entrySet()`: Returns a set view of the mappings contained in this map.
   - You can iterate over the keys, values, or entries of the map using these methods.

**Example**:
```java
HashMap<String, Integer> hashMap = new HashMap<>();
hashMap.put("One", 1);
hashMap.put("Two", 2);
hashMap.put("Three", 3);

// Iterating over keys
for (String key : hashMap.keySet()) {
    // {key: "Key", value: "Value"} pair
    System.out.println("{Key: " + key+", value: "+hashmap.get(key)+"}");
}

// Iterating over values
for (Integer value : hashMap.values()) {
    System.out.println("Value: " + value);
}

// Iterating over entries (key-value pairs)
for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
```

In this example, we create a `HashMap`, add elements to it, and then demonstrate different ways to iterate over its keys, values, and entries. This showcases how you can iterate over a `HashMap` using its various iteration methods.

## TreeMap In JAVA
`TreeMap` in Java is an implementation of the `SortedMap` interface, based on a Red-Black tree. It provides a key-value mapping and maintains the elements in ascending order of their keys, or according to a custom comparator provided at the time of creation. Here's an overview of `TreeMap` and its methods:

1. **Creating a TreeMap**:
   You can create a `TreeMap` instance by simply instantiating it. Optionally, you can provide a comparator to define the ordering of the keys.

   ```java
   TreeMap<Integer, String> treeMap = new TreeMap<>();
   ```

   or with a custom comparator:

   ```java
   TreeMap<Integer, String> treeMap = new TreeMap<>(Comparator.reverseOrder());
   ```

2. **Adding or Updating Elements**:
   - `V put(K key, V value)`: Associates the specified value with the specified key in this map.

3. **Removing Elements**:
   - `V remove(Object key)`: Removes the mapping for the specified key from this map if present.
   - `void clear()`: Removes all of the mappings from this map.

4. **Accessing Elements**:
   - `V get(Object key)`: Returns the value to which the specified key is mapped, or `null` if this map contains no mapping for the key.
   - `boolean containsKey(Object key)`: Returns `true` if this map contains a mapping for the specified key.
   - `boolean containsValue(Object value)`: Returns `true` if this map maps one or more keys to the specified value.

5. **Size and Clearing**:
   - `int size()`: Returns the number of key-value mappings in this map.
   - `boolean isEmpty()`: Returns `true` if this map contains no key-value mappings.

6. **Iteration**:
   - `Set<K> keySet()`: Returns a set view of the keys contained in this map.
   - `Collection<V> values()`: Returns a collection view of the values contained in this map.
   - `Set<Map.Entry<K, V>> entrySet()`: Returns a set view of the mappings contained in this map.

**Example**:
```java
TreeMap<Integer, String> treeMap = new TreeMap<>();
treeMap.put(3, "Three");
treeMap.put(1, "One");
treeMap.put(2, "Two");

// Iterating over the keys
for (Integer key : treeMap.keySet()) {
    System.out.println("Key: " + key + ", Value: " + treeMap.get(key));
}

// Iterating over the entries (key-value pairs)
for (Map.Entry<Integer, String> entry : treeMap.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
```

In this example, we create a `TreeMap`, add elements to it, and then iterate over its keys and key-value pairs using different methods provided by the `TreeMap`. This demonstrates how you can iterate over the elements of a `TreeMap`.

## LinkedHashMap In JAVA
`LinkedHashMap` in Java is a class that extends `HashMap` to maintain a `linked list of entries in the order they were inserted`. It combines the features of a hash table and a linked list, providing fast retrieval and predictable iteration order. Here's an overview of `LinkedHashMap` and its methods:

1. **Creating a LinkedHashMap**:
   You can create a `LinkedHashMap` instance by simply instantiating it. Optionally, you can specify the initial capacity, load factor, and whether the access order should be maintained (`true` for access-order, `false` for insertion-order).

   ```java
   LinkedHashMap<Integer, String> linkedHashMap = new LinkedHashMap<>();
   ```

   or with specified initial capacity and load factor:

   ```java
   LinkedHashMap<Integer, String> linkedHashMap = new LinkedHashMap<>(16, 0.75f);
   ```

   or with access-order:

   ```java
   LinkedHashMap<Integer, String> linkedHashMap = new LinkedHashMap<>(16, 0.75f, true);
   ```

2. **Adding and Removing Elements**:
   - `V put(K key, V value)`: Associates the specified value with the specified key in this map.
   - `void putAll(Map<? extends K, ? extends V> m)`: Copies all of the mappings from the specified map to this map.
   - `V remove(Object key)`: Removes the mapping for the specified key from this map if present.
   - `void clear()`: Removes all of the mappings from this map.

3. **Accessing and Checking Elements**:
   - `V get(Object key)`: Returns the value to which the specified key is mapped, or `null` if this map contains no mapping for the key.
   - `boolean containsKey(Object key)`: Returns `true` if this map contains a mapping for the specified key.

4. **Size and Clearing**:
   - `int size()`: Returns the number of key-value mappings in this map.
   - `boolean isEmpty()`: Returns `true` if this map contains no key-value mappings.

5. **Iteration**:
   - `Set<Map.Entry<K, V>> entrySet()`: Returns a `Set` view of the mappings contained in this map.
   - `Collection<V> values()`: Returns a `Collection` view of the values contained in this map.
   - `Set<K> keySet()`: Returns a `Set` view of the keys contained in this map.

**Example**:
```java
LinkedHashMap<Integer, String> linkedHashMap = new LinkedHashMap<>();
linkedHashMap.put(1, "One");
linkedHashMap.put(2, "Two");
linkedHashMap.put(3, "Three");

// Iterating over the entries
for (Map.Entry<Integer, String> entry : linkedHashMap.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}

// Iterating over the keys
for (Integer key : linkedHashMap.keySet()) {
    System.out.println("Key: " + key);
}

// Iterating over the values
for (String value : linkedHashMap.values()) {
    System.out.println("Value: " + value);
}
```

In this example, we create a `LinkedHashMap`, add elements to it, and then iterate over the entries, keys, and values using various methods provided by `LinkedHashMap`. This demonstrates how you can iterate over a `LinkedHashMap`.


## LinkedHashMap As Cache Handler
Using `LinkedHashMap` as a cache handler is a common practice due to its ability to maintain the insertion order of elements. This makes it suitable for implementing a Least Recently Used (LRU) cache, where the least recently accessed items are evicted when the cache reaches its maximum capacity.

Here's a basic example of how you can use `LinkedHashMap` as a cache handler:

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75f, true); // Access-ordering mode (true)
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }

    public static void main(String[] args) {
        LRUCache<Integer, String> cache = new LRUCache<>(3);

        cache.put(1, "One");
        cache.put(2, "Two");
        cache.put(3, "Three");

        // Accessing 1 to make it the most recently used
        cache.get(1);

        cache.put(4, "Four"); // Evicts "Two"

        // Displaying cache content
        System.out.println(cache);
    }
}
```

In this example:

- We extend `LinkedHashMap` and override `removeEldestEntry` to specify the eviction policy (removing the eldest entry when the size exceeds the capacity).
- We use `put` to add elements to the cache.
- We use `get` to access elements from the cache, which updates their position to the most recently used.
- When we try to add a new element (`"Four"`), the size of the cache exceeds its capacity, causing the eldest entry (`"Two"`) to be evicted.

This approach ensures that the least recently used elements are automatically removed when the cache reaches its capacity, making it an effective cache handler.

Another Example:
```java
import java.util.*;

public class LinkedHashMapDemo 
{
    public static void main(String[] args) 
    {
        LinkedHashMap<Integer,String> lhm=new LinkedHashMap<>(5){
            
            protected boolean removeEldestEntry(Map.Entry e)
            {
                return size()>5;
            }
        };
        
        lhm.put(1,"A");
        lhm.put(2,"B");
        lhm.put(3,"C");
        lhm.put(4,"D");
        lhm.put(5,"E");
        String s=lhm.get(2);
        s=lhm.get(5);
        s=lhm.get(1);
        lhm.put(6,"F");
        
        lhm.forEach((k,v)->System.out.println(k+" "+v));
        
    }   
}
```


## LinkedHashSet In JAVA
`LinkedHashSet` in Java is an implementation of the `Set` interface that extends `HashSet` and maintains a doubly-linked list running through all of its entries. It combines the features of a `HashSet` (no duplicate elements, no guarantee on the order of elements) with the predictable iteration order of a `LinkedHashMap`. Here's an overview of `LinkedHashSet` and its methods:

1. **Creating a LinkedHashSet**:
   You can create a `LinkedHashSet` instance by simply instantiating it:

   ```java
   LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();
   ```

2. **Adding Elements**:
   - `boolean add(E e)`: Adds the specified element to the set if it is not already present.
   - `void addAll(Collection<? extends E> c)`: Adds all of the elements in the specified collection to the set.

3. **Removing Elements**:
   - `boolean remove(Object o)`: Removes the specified element from the set if it is present.
   - `void clear()`: Removes all elements from the set.

4. **Accessing Elements**:
   - `boolean contains(Object o)`: Returns `true` if the set contains the specified element.
   - `int size()`: Returns the number of elements in the set.
   - `boolean isEmpty()`: Returns `true` if the set contains no elements.

5. **Iteration**:
   - `Iterator<E> iterator()`: Returns an iterator over the elements in the set.
   - `forEach(Consumer<? super E> action)`: Performs the given action for each element of the set until all elements have been processed or the action throws an exception.

**Example**:
```java
LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add("One");
linkedHashSet.add("Two");
linkedHashSet.add("Three");

// Iterating over the elements using enhanced for-loop
for (String element : linkedHashSet) {
    System.out.println(element);
}

// Iterating over the elements using Iterator
Iterator<String> iterator = linkedHashSet.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
```

In this example, we create a `LinkedHashSet`, add elements to it, and then iterate over the elements using both the enhanced for-loop and an explicit `Iterator`. This demonstrates two common ways to iterate over a `LinkedHashSet`.


Another Example:
```java
import java.util.*;

public class LinkedHashSetDemo 
{
    public static void main(String[] args) 
    {
        HashSet<String> lhs=new HashSet<>(10);
        
        lhs.add("A");
        lhs.add("C");
        lhs.add("E");
        lhs.add("K");
        lhs.add("B");
        lhs.add("G");
        lhs.add("B");
        
        Iterator<String> itr=lhs.iterator();
        
        while(itr.hasNext())
        {
            System.out.println(itr.next());
        }
        
        Hashtable ht=new Hashtable(10);
        
    }   
}
```

## HashTable In JAVA
`HashTable` in Java is a legacy class that implements the `Map` interface and extends the `Dictionary` class. It provides a hashtable-based implementation of the `Map` interface, offering key-value pairs where keys and values are `Object` references. Here's an overview of `HashTable` and its methods:

1. **Creating a HashTable**:
   You can create a `HashTable` instance by simply instantiating it:

   ```java
   Hashtable<Integer, String> hashTable = new Hashtable<>();
   ```

2. **Adding and Updating Elements**:
   - `V put(K key, V value)`: Associates the specified value with the specified key in this hashtable.
   - `void putAll(Map<? extends K,? extends V> t)`: Copies all of the mappings from the specified map to this hashtable.

3. **Removing Elements**:
   - `V remove(Object key)`: Removes the mapping for the specified key from this hashtable if present.
   - `void clear()`: Removes all of the mappings from this hashtable.

4. **Accessing Elements**:
   - `V get(Object key)`: Returns the value to which the specified key is mapped, or `null` if this map contains no mapping for the key.
   - `boolean containsKey(Object key)`: Returns `true` if this hashtable contains a mapping for the specified key.
   - `boolean containsValue(Object value)`: Returns `true` if this map maps one or more keys to the specified value.

5. **Size and Clearing**:
   - `int size()`: Returns the number of key-value mappings in this hashtable.
   - `boolean isEmpty()`: Returns `true` if this hashtable contains no mappings.

6. **Iteration**:
   - `Enumeration<K> keys()`: Returns an enumeration of the keys in this hashtable.
   - `Enumeration<V> elements()`: Returns an enumeration of the values in this hashtable.

**Example**:
```java
Hashtable<Integer, String> hashTable = new Hashtable<>();
hashTable.put(1, "One");
hashTable.put(2, "Two");
hashTable.put(3, "Three");

// Iterating over keys
Enumeration<Integer> keys = hashTable.keys();
while (keys.hasMoreElements()) {
    Integer key = keys.nextElement();
    System.out.println("Key: " + key + ", Value: " + hashTable.get(key));
}
```

In this example, we create a `Hashtable`, add elements to it, and then iterate over the keys using the `keys()` method. We retrieve the value corresponding to each key using the `get()` method. This demonstrates how to iterate over a `Hashtable` using enumeration.

Another Example:
```java
import java.util.*;

public class HashTableDemo 
{
    public static void main(String[] args) 
    {
        // Hashtable ht=new Hashtable<>(); also fine
        Hashtable<Integer,String> ht=new Hashtable<>();
        
        ht.put(1,"A");
        ht.put(2,"B");
        ht.put(3,"C");
        ht.put(4,"D");
        ht.put(5,"E");
        
        
        Enumeration e=ht.elements();
        while(e.hasMoreElements())
        {
            System.out.println(e.nextElement());
        }
        
        ht.computeIfAbsent(7, (k)->"Z"+k);

        System.out.println(ht);
        
        
    }   
}
```

## Properties Class In JAVA
The `Properties` class in Java is a subclass of `Hashtable` and represents a persistent set of properties. The `Properties` can be saved to a stream or loaded from a stream. It's commonly used for application configuration, where key-value pairs are stored in a properties file. Here's an overview of `Properties` and its methods:

1. **Creating a Properties Object**:
   You can create a `Properties` object and initialize it with default properties, or load properties from a file.

   ```java
   Properties properties = new Properties();
   ```

2. **Setting and Getting Properties**:
   - `Object setProperty(String key, String value)`: Associates the specified value with the specified key in this property list.
   - `String getProperty(String key)`: Searches for the property with the specified key in this property list.
   - `String getProperty(String key, String defaultValue)`: Searches for the property with the specified key in this property list.
   - `void load(InputStream inStream)`: Reads a property list (key and element pairs) from the input byte stream.
   - `void store(OutputStream out, String comments)`: Writes this property list (key and element pairs) in this `Properties` table to the output stream in a format suitable for loading into a `Properties` table using the `load` method.

3. **Iterating Over Properties**:
   - `Enumeration<?> propertyNames()`: Returns an enumeration of all the keys in this property list, including distinct keys in the default property list if a key of the same name has not already been found from the main properties list.

**Example**:
```java
Properties properties = new Properties();
properties.setProperty("url", "jdbc:mysql://localhost/mydb");
properties.setProperty("username", "root");
properties.setProperty("password", "password");

// Storing properties to a file
try (OutputStream output = new FileOutputStream("config.properties")) {
    properties.store(output, "Database Configuration");
} catch (IOException e) {
    e.printStackTrace();
}

// Loading properties from a file
Properties loadedProperties = new Properties();
try (InputStream input = new FileInputStream("config.properties")) {
    loadedProperties.load(input);
} catch (IOException e) {
    e.printStackTrace();
}

// Iterating over properties
Enumeration<?> propertyNames = loadedProperties.propertyNames();
while (propertyNames.hasMoreElements()) {
    String key = (String) propertyNames.nextElement();
    String value = loadedProperties.getProperty(key);
    System.out.println(key + ": " + value);
}
```

In this example:
- We set properties using `setProperty`.
- We store properties to a file using `store`.
- We load properties from a file using `load`.
- We iterate over properties using `propertyNames`.

Another Example:
```java
import java.util.*;
import java.io.*;

public class PropertyDemo 
{
    public static void main(String[] args) throws Exception
    {
        Properties p=new Properties();
        
        p.setProperty("Brand", "Dell");
        p.setProperty("Processor", "i7");
        p.setProperty("OS", "Windows10");
        p.setProperty("Model", "Latitude");
        
        
        p.storeToXML(new FileOutputStream("MyData.xml"), "Laptop");
        
        
        p.load(new FileInputStream("MyData.txt"));
        
        System.out.println(p);
               
    }  
}
```

## String Tokeniser In JAVA
In Java, the `StringTokenizer` class is used to break a string into tokens. A token is a sequence of characters separated by one or more `delimiter characters(\n is default)`. Here's an overview of how to use `StringTokenizer`:

1. **Creating a StringTokenizer**:
   You can create a `StringTokenizer` instance by providing the string to be tokenized and the delimiter(s) used to separate the tokens.

   ```java
   StringTokenizer tokenizer = new StringTokenizer("Hello, world! This is a test.", ",! ");
   ```

   In this example, the string "Hello, world! This is a test." will be tokenized using the delimiters `,`, `!`, and space.

2. **Methods for Accessing Tokens**:
   - `boolean hasMoreTokens()`: Returns `true` if there are more tokens in the string, otherwise returns `false`.
   - `String nextToken()`: Returns the next token from the string.
   - `String nextToken(String delim)`: Returns the next token using the specified delimiter string.

3. **Counting Tokens**:
   - `int countTokens()`: Returns the number of tokens in the string.

**Example**:
```java
StringTokenizer tokenizer = new StringTokenizer("Hello, world! This is a test.", ",! ");
while (tokenizer.hasMoreTokens()) {
    String token = tokenizer.nextToken();
    System.out.println(token);
}
```

In this example, the string "Hello, world! This is a test." will be tokenized using the delimiters `,`, `!`, and space. Each token will be printed on a separate line.

**Using Custom Delimiters**:
```java
StringTokenizer tokenizer = new StringTokenizer("apple,banana,cherry", ",");
while (tokenizer.hasMoreTokens()) {
    String fruit = tokenizer.nextToken();
    System.out.println(fruit);
}
```

In this example, the string "apple,banana,cherry" will be tokenized using `,` as the delimiter. Each fruit will be printed on a separate line.

`StringTokenizer` is a legacy class, and its use is discouraged in favor of using the `split()` method of the `String` class or the `Scanner` class, which provides more flexibility and functionality.

Another Example:
```java
import java.util.*;
import java.io.*;

public class TokenizerDemo {

    public static void main(String[] args) throws Exception
    {
        // File path must be valid
        FileInputStream fis=new FileInputStream("/Users/abdulbari/Documents/Data.txt");
        byte b[]=new byte[fis.available()];
        fis.read(b);
        
        String data=new String(b);

        //String data="name=Vijay address=delhi country=india dept=cse";
    
        
        StringTokenizer stk=new StringTokenizer(data,",");
        
        String s;
        ArrayList<Integer> al=new ArrayList<>();
        
        while(stk.hasMoreTokens())
        {
            s=stk.nextToken();
            al.add(Integer.valueOf(s));
            
        }
        
        System.out.println(al);

    }
    
}
```

## BitSet In JAVA
In Java, `BitSet` is a class that represents a resizable array of bits. It's similar to an array of boolean values but more memory-efficient, as each bit only requires one bit of memory. Here's an overview of `BitSet` and its methods:

1. **Creating a BitSet**:
   You can create a `BitSet` instance by simply instantiating it.

   ```java
   BitSet bitSet = new BitSet();
   ```

2. **Setting and Clearing Bits**:
   - `void set(int bitIndex)`: Sets the bit at the specified index to true.
   - `void clear(int bitIndex)`: Clears the bit at the specified index to false.
   - `void flip(int bitIndex)`: Flips the bit at the specified index.
   - `void set(int bitIndex, boolean value)`: Sets the bit at the specified index to the specified value.
   - `void clear()`: Clears all bits in the `BitSet`.

3. **Getting the State of Bits**:
   - `boolean get(int bitIndex)`: Returns the value of the bit at the specified index.
   - `int nextSetBit(int fromIndex)`: Returns the index of the first bit that is set to true, starting from the specified index.
   - `int nextClearBit(int fromIndex)`: Returns the index of the first bit that is set to false, starting from the specified index.

4. **Size and Cardinality**:
   - `int size()`: Returns the number of bits in the `BitSet`.
   - `int cardinality()`: Returns the number of bits set to true in the `BitSet`.

5. **Operations**:
   - `void and(BitSet set)`: Performs a logical AND of this `BitSet` with another `BitSet`.
   - `void or(BitSet set)`: Performs a logical OR of this `BitSet` with another `BitSet`.
   - `void xor(BitSet set)`: Performs a logical XOR of this `BitSet` with another `BitSet`.
   - `void andNot(BitSet set)`: Clears all bits in this `BitSet` that are also set in another `BitSet`.

**Example**:
```java
BitSet bitSet = new BitSet();

// Set some bits
bitSet.set(0);
bitSet.set(2);
bitSet.set(4);

// Print the BitSet
System.out.println("BitSet: " + bitSet);

// Check if a bit is set
System.out.println("Is bit 1 set? " + bitSet.get(1));

// Clear a bit
bitSet.clear(2);

// Print the BitSet again
System.out.println("BitSet after clearing bit 2: " + bitSet);

// Find the next set bit
System.out.println("Next set bit after index 0: " + bitSet.nextSetBit(0));

// Get the cardinality (number of set bits)
System.out.println("Number of set bits: " + bitSet.cardinality());
```

Output:
```
BitSet: {0, 2, 4}
Is bit 1 set? false
BitSet after clearing bit 2: {0, 4}
Next set bit after index 0: 0
Number of set bits: 2
```

In this example, we create a `BitSet`, set some bits, clear a bit, find the next set bit, and get the cardinality of the `BitSet`. `BitSet` provides efficient operations for manipulating sets of bits.

Another Example:
```java
import java.util.*;

public class BitSetDemo 
{
    public static void main(String[] args) 
    {
        BitSet bs1=new BitSet();
        
        bs1.set(0);
        bs1.set(2);
        bs1.set(4);
        bs1.set(6);
        bs1.set(8);
           
        BitSet bs2=new BitSet();
       // bs2.set(0);
        bs2.set(1);
       // bs2.set(2);
        bs2.set(3);
       // bs2.set(4);
        bs2.set(5);
       // bs2.set(6);
        bs2.set(7);
       // bs2.set(8);
        
        bs1.and(bs2);
        bs1.or(bs2);
        
        bs1.flip(0,bs1.length());
        System.out.println(bs1);
        
    }  
}
```

## Compare Method In JAVA
In Java, the `compare` method is typically used in classes that implement the `Comparator` interface. This interface defines a single method, `compare`, which is used to compare two objects for order. The `compare` method is often used in sorting and ordering operations. Here's an overview of the `compare` method:

```java
int compare(T o1, T o2);
```

- **Parameters**:
  - `o1`: The first object to be compared.
  - `o2`: The second object to be compared.

- **Return Value**:
  - Returns a negative integer, zero, or a positive integer if the first object is less than, equal to, or greater than the second object, respectively.

**Example**:
Suppose you have a class `Person` with attributes `name` and `age`, and you want to sort a list of `Person` objects based on their ages. You can create a `Comparator` for `Person` objects and implement the `compare` method to compare their ages:

```java
import java.util.Comparator;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getters and setters

    // Comparator for comparing Person objects based on age
    public static Comparator<Person> ageComparator = new Comparator<Person>() {
        @Override
        public int compare(Person p1, Person p2) {
            return Integer.compare(p1.getAge(), p2.getAge());
        }
    };
}
```

Now, you can use this comparator to sort a list of `Person` objects based on their ages:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Charlie", 35));

        // Sort people based on age
        Collections.sort(people, Person.ageComparator);

        // Print sorted list
        for (Person person : people) {
            System.out.println(person.getName() + " - " + person.getAge());
        }
    }
}
```

Output:
```
Bob - 25
Alice - 30
Charlie - 35
```

In this example, the `compare` method defined in the `ageComparator` comparator compares `Person` objects based on their ages, allowing us to sort a list of `Person` objects based on age.

Another Example:
```java
import java.util.*;

class My implements Comparator<Integer>
{
    public int compare(Integer i1,Integer i2)
    {
        if(i1<i2)
            return 1;
        if(i1>i2)
            return -1;
        return 0;
    }
}

public class ComparatorDemo 
{
    public static void main(String[] args) 
    {
        Integer a[]={2,4,6,8,1,3,5,7};
        
        
        Arrays.sort(a);
        
       for(Integer x:a) 
            System.out.println(x);

    }   
}
```
