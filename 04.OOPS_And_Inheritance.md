## CLASSES AND OBJECTS IN JAVA
In Java, classes and objects are fundamental concepts of object-oriented programming (OOP). Let's delve into each of these concepts:

### Classes:
- A class in Java is a `blueprint or template` for creating objects.
- It `encapsulates` data for the object (attributes or fields) and methods (functions or behaviors) that operate on that data.
- Classes are defined using the `class` keyword followed by the class name.
- They can have constructors for initializing objects and can also have static and instance methods.
- Classes facilitate code reusability, abstraction, and modularity.

Example of a class:

```java
public class Car {
    // Attributes or fields
    String make;
    String model;
    int year;

    // Constructor
    public Car(String make, String model, int year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }

    // Method
    public void displayInfo() {
        System.out.println("Make: " + make + ", Model: " + model + ", Year: " + year);
    }
}
```

### Objects:
- An object is an `instance` of a class. It represents a real-world entity with properties and behaviors defined by its class.
- Objects are created using the `new` keyword followed by a call to a class constructor.
- Each object has its own set of attributes and methods, independent of other objects of the same class.
- Objects interact with each other through method calls and can hold references to each other.

Example of creating objects:

```java
public class Main {
    public static void main(String[] args) {
        // Creating objects of class Car
        Car car1 = new Car("Toyota", "Camry", 2022);
        Car car2 = new Car("Honda", "Civic", 2021);

        // Calling methods on objects
        car1.displayInfo();
        car2.displayInfo();
    }
}
```

In the above example, `car1` and `car2` are instances of the `Car` class. Each object has its own values for the `make`, `model`, and `year` attributes, and they can invoke the `displayInfo()` method independently.

Classes and objects form the foundation of object-oriented programming in Java, enabling the creation of modular, reusable, and maintainable code. They facilitate modeling real-world entities and implementing complex systems with ease.


## NULL IN JAVA
In Java, `null` is a special literal that represents the absence of an object reference. It is commonly used to indicate that a reference variable does not refer to any object. Here's how `null` is used with objects in Java:

1. **Initialization:**
   Variables of reference types (objects) can be initialized to `null` when you want to indicate that they are not currently referencing any object.

   ```java
   MyClass obj = null;
   ```

2. **Default Value:**
   If you declare a reference variable without explicitly initializing it, Java assigns it a default value of `null`.

   ```java
   MyClass obj; // obj is initialized to null by default
   ```

3. **Returning from Methods:**
   Methods can return `null` to indicate that no valid object could be returned.

   ```java
   public MyClass getObject() {
       if (someCondition) {
           return new MyClass();
       } else {
           return null;
       }
   }
   ```

4. **Comparisons:**
   You can compare an object reference with `null` to check if it's not referring to any object.

   ```java
   MyClass obj = null;
   if (obj == null) {
       // obj does not refer to any object
   }
   ```

5. **Avoiding NullPointerExceptions (NPE):**
   Accessing methods or fields of an object that is `null` results in a `NullPointerException` at runtime. It's important to handle such cases appropriately to avoid program crashes.

   ```java
   MyClass obj = null;
   if (obj != null) {
       obj.someMethod(); // Safe to call methods if obj is not null
   }
   ```

5. **Default Counstructor Always Puts Null In Instance Variables:**
   when a object is created using default counstructor than the instance variables treated as `null` or `default value` as 
   for `boolean` default value is `false`.
   for `double/float` default value is `0.0`.
   for `Any Integer Type` default value is `0`.
   for `reffrences fields` default value is `null`.

   ```java
   MyClass obj = new MyClass();
   ```


`null` can be used effectively in Java to handle scenarios where the absence of an object reference needs to be represented. However, it's essential to handle `null` references appropriately to avoid runtime exceptions and ensure the stability and correctness of your programs.

## Getters And Setters In JAVA
Getters and setters are methods used to access and modify the private fields (attributes) of a Java class. They follow the principles of encapsulation, allowing controlled access to the class's attributes while providing data validation or additional logic if needed. Here's an overview of getters and setters in Java:

1. **Getters:**
   - Getters are methods used to retrieve the value of a private field.
   - They typically have the prefix `get` followed by the name of the field with the first letter capitalized.
   - Getters return the value of the field without modifying it.

   ```java
   public class MyClass {
       private int number;

       // Getter for 'number'
       public int getNumber() {
           return number;
       }
   }
   ```

2. **Setters:**
   - Setters are methods used to set the value of a private field.
   - They typically have the prefix `set` followed by the name of the field with the first letter capitalized.
   - Setters take a parameter representing the new value to be assigned to the field.
   - They can include validation logic to ensure that the new value meets certain criteria.

   ```java
   public class MyClass {
       private int number;

       // Setter for 'number'
       public void setNumber(int number) {
           if (number >= 0) { // Example validation
               this.number = number;
           } else {
               System.out.println("Number must be non-negative.");
           }
       }
   }
   ```

3. **Usage:**
   - Getters and setters allow controlled access to private fields, promoting encapsulation and data integrity.
   - They provide a mechanism for accessing and modifying private fields from outside the class, ensuring that the class's internal state remains consistent.

   ```java
   public class Main {
       public static void main(String[] args) {
           MyClass obj = new MyClass();

           // Using setter to modify the value of 'number'
           obj.setNumber(10);

           // Using getter to retrieve the value of 'number'
           int value = obj.getNumber();
           System.out.println("Value of 'number': " + value);
       }
   }
   ```

4. **Benefits:**
   - Encapsulation: Getters and setters encapsulate the internal state of an object, hiding its implementation details.
   - Flexibility: They provide flexibility in modifying the behavior of accessing or modifying attributes without changing the external interface of the class.
   - Data Validation: Setters can include validation logic to ensure that only valid data is assigned to the fields.

Getters and setters are a common pattern in Java programming, facilitating the implementation of encapsulation and ensuring the integrity of class data. They are a fundamental part of writing maintainable and robust object-oriented code.

## This Keyword In JAVA
In Java, the `this` keyword is a reference to the current object within an instance method or a constructor. It can be used to refer to the current instance's fields, methods, or constructors. Here's an overview of how `this` keyword is used in Java:

1. **Accessing Instance Variables:**
   `this` keyword is used to access instance variables when there is a naming conflict between a local variable and an instance variable.

   ```java
   public class MyClass {
       private int number;

       public void setNumber(int number) {
           // Using 'this' to refer to the instance variable
           this.number = number;
       }
   }
   ```

2. **Invoking Current Object's Methods:**
   `this` keyword can be used to invoke other methods of the current object from within an instance method.

   ```java
   public class MyClass {
       public void method1() {
           // Invoking method2() of the current object
           this.method2();
       }

       public void method2() {
           // Method implementation
       }
   }
   ```

3. **Referring to Current Object:**
   `this` keyword can be used to pass the current object as an argument or return it from a method.

   ```java
   public class MyClass {
       public MyClass getInstance() {
           // Returning the current object
           return this;
       }
   }
   ```

4. **Constructor Chaining:**
   `this` keyword can be used to call another constructor of the same class from within a constructor. This is known as constructor chaining.

   ```java
   public class MyClass {
       private int number;

       public MyClass() {
           // Calling another constructor of the same class
           this(0); // Constructor chaining
       }

       public MyClass(int number) {
           this.number = number;
       }
   }
   ```

5. **Passing `this` to Other Methods or Constructors:**
   `this` keyword can be passed as an argument to other methods or constructors. It is often useful in event handling or callback scenarios.

   ```java
   public class MyClass {
       public void method1() {
           OtherClass.process(this);
       }
   }

   public class OtherClass {
       public static void process(MyClass obj) {
           // Processing the MyClass object
       }
   }
   ```

6. **Using `this` with Inner Classes:(IMP TO NOTE)**
   When working with inner classes, `this` refers to the current instance of the inner class. To refer to the enclosing instance, you can use `OuterClassName.this`.

   ```java
   public class OuterClass {
       private int x;

       public class InnerClass {
           public void method() {
               // Referring to the outer class instance
               OuterClass.this.x = 10;
           }
       }
   }
   ```

In summary, the `this` keyword is a reference to the current object in Java and is commonly used to disambiguate instance variables from local variables, access other methods or constructors of the same object, and pass the current object as an argument or return it from a method.

## Constructors In JAVA
In Java, constructors are special methods used for initializing objects. They are called automatically when an object is created using the `new` keyword. Constructors have the same name as the class and can have parameters to initialize the object with specific values. Here's an overview of constructors in Java:

1. **Default Constructor:**
   - If a class does not explicitly define any constructors, Java provides a `default` constructor.
   - The default constructor has no parameters and initializes the object with default values (e.g., numeric fields are set to `0`, reference fields are set to `null`).

   ```java
   public class MyClass {
       // Default constructor (provided by Java if not explicitly defined)
       public MyClass() {
           // Constructor implementation
       }
   }
   ```

2. **Parameterized Constructor:**
   - A parameterized constructor allows you to initialize object fields with specified values when the object is created.
   - It has parameters corresponding to the fields of the class.

   ```java
   public class MyClass {
       private int number;

       // Parameterized constructor
       public MyClass(int number) {
           this.number = number;
       }
   }
   ```

3. **Constructor Overloading:**
   - Java allows constructors to be overloaded, meaning a class can have multiple constructors with different parameter lists.
   - Overloaded constructors provide flexibility in initializing objects with different sets of values.

   ```java
   public class MyClass {
       private int number;

       // Parameterized constructor
       public MyClass(int number) {
           this.number = number;
       }

       // Overloaded constructor with no parameters
       public MyClass() {
           this.number = 0;
       }
   }
   ```

4. **Chaining Constructors (Constructor Delegation):**
   - Constructors can call other constructors of the same class using `this()` keyword.
   - This feature is known as constructor chaining.

   ```java
   public class MyClass {
       private int number;

       // Parameterized constructor
       public MyClass(int number) {
           this.number = number;
       }

       // Overloaded constructor chaining to the parameterized constructor
       public MyClass() {
           this(0); // Calling parameterized constructor
       }
   }
   ```

5. **Implicit Super Constructor Call:**
   - If a class extends another class and does not explicitly call a superclass constructor using `super()`, Java inserts a call to the superclass's no-argument constructor automatically.
   - If the superclass does not have a no-argument constructor, the subclass must explicitly call one of the superclass constructors using `super()`.

Constructors are essential for initializing object state and ensuring that objects are in a valid state when they are created. They play a crucial role in object-oriented programming by providing a mechanism for object initialization and ensuring proper encapsulation of object state.

## Refference, Objects And Classes
In Java, references and objects are fundamental concepts that play a crucial role in object-oriented programming. Understanding their relationship is essential for writing Java programs effectively. Here's an overview:

### References:
- A reference in Java is a variable that holds the memory address of an object.
- References allow you to access and manipulate objects indirectly.
- They are similar to pointers in other programming languages but are managed by the Java Virtual Machine (JVM), providing automatic memory management (garbage collection).
- Reference variables are declared using a specific type corresponding to the class of objects they can reference.

Example of declaring a reference variable:
```java
MyClass obj; // Declaration of a reference variable
```

### Objects:
- An object in Java is an instance of a class. It represents a real-world entity with properties (attributes) and behaviors (methods).
- Objects are created using the `new` keyword followed by a call to a class constructor.
- Each object has its own memory space allocated in the heap memory, containing its state (attributes) and behavior (methods).

Example of creating an object:
```java
MyClass obj = new MyClass(); // Creating an object of MyClass
```

### Relationship between References and Objects:
- References are used to access and manipulate objects in Java.
- Multiple references can refer to the same object, allowing different parts of the program to interact with the same object.
- A reference variable can be assigned to `null`, indicating that it does not currently refer to any object.
- Objects are created dynamically at runtime, and their memory is allocated in the heap.
- When an object is no longer referenced by any variables, it becomes eligible for garbage collection, and its memory is reclaimed by the JVM.

Example demonstrating references and objects:
```java
MyClass obj1 = new MyClass(); // Creating an object and assigning its reference to obj1
MyClass obj2 = obj1; // Assigning the reference of obj1 to obj2, both now refer to the same object
obj1.someMethod(); // Accessing a method of the object using obj1 reference
obj2.someOtherMethod(); // Accessing a method of the object using obj2 reference
obj1 = null; // Setting obj1 reference to null, object is still referenced by obj2
```

In summary, references and objects are integral parts of Java programming, facilitating the creation, manipulation, and interaction of objects within a program. Understanding how references work with objects is crucial for writing efficient and maintainable Java code.

## Static Vs Instance Variables And Methods
In Java, both static and instance variables and methods are used to define behaviors and properties of classes and objects, but they serve different purposes and have distinct characteristics:

### Static Variables:
- Static variables, also known as class variables, belong to the class rather than any specific instance of the class.
- There is only one copy of a static variable shared among all instances of the class.
- Static variables are declared using the `static` keyword.
- They are initialized only once, at the time the class is loaded into memory.
- Static variables are accessed using the class name, not through instances of the class.

Example of a static variable:
```java
public class MyClass {
    static int count = 0; // Static variable
}
```

### Instance Variables:
- Instance variables, also known as non-static variables, belong to individual instances (objects) of the class.
- Each instance of the class has its own copy of instance variables.
- Instance variables are declared without the `static` keyword.
- They are initialized when an object of the class is created and are specific to that instance.

Example of an instance variable:
```java
public class MyClass {
    int id; // Instance variable
}
```

### Static Methods:
- Static methods, also known as class methods, belong to the class rather than any specific instance.
- They can be `called using the class name` without creating an instance of the class.
- `Static methods cannot access instance variables directly because they don't belong to any instance`. They can only access static variables.
- Static methods are commonly used for utility functions or operations that don't require access to instance-specific data.

Example of a static method:
```java
public class MyClass {
    static void printMessage() { // Static method
        System.out.println("Hello, world!");
    }
}
```

### Instance Methods:
- Instance methods belong to individual instances (objects) of the class.
- They operate on the instance variables of the class and can access both instance variables and static variables directly.
- Instance methods are invoked using an instance of the class.
- They are used to perform operations specific to individual instances of the class.

Example of an instance method:
```java
public class MyClass {
    void printInfo() { // Instance method
        System.out.println("Instance method");
    }
}
```

### When to Use:
- Use static variables and methods when you want a property or behavior to be shared among all instances of the class.
- Use instance variables and methods when you want properties or behaviors to be specific to each instance of the class.

In summary, static variables and methods belong to the class itself, while instance variables and methods belong to individual instances (objects) of the class. Understanding the distinction between static and instance members is crucial for designing and implementing object-oriented programs effectively in Java.

## POJO(Plain Old Java Object) in JAVA
Plain Old Java Object (POJO) is a term used in Java development to refer to a simple Java object that does not depend on any external framework or library. It is a regular Java object that adheres to a set of conventions and principles, making it easy to understand, maintain, and integrate with other parts of the codebase. Here are some characteristics of POJOs:

1. **Simple Structure:** POJOs typically consist of private fields, public getter and setter methods, and optionally some additional behavior methods.

2. **No Framework Dependency:** POJOs should not depend on any external framework or library. They are independent of technologies such as Enterprise JavaBeans (EJB), Spring, or Hibernate.

3. **Plain Java Classes:** POJOs are plain Java classes that follow standard Java conventions and best practices. They are not bound by any special rules or annotations imposed by frameworks.

4. **Serializable:** POJOs may implement the `Serializable` interface to support serialization and deserialization, allowing them to be stored or transmitted as byte streams.

5. **Used for Data Transfer:** POJOs are commonly used for data transfer objects (DTOs), domain objects, or entities in Java applications. They represent data structures that hold information and do not contain any business logic.

Example of a simple POJO:
```java
public class Person {
    private String name;
    private int age;

    // Constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getter and Setter methods
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

POJOs provide a lightweight and flexible way to represent data in Java applications. They are widely used in various contexts, including web development, enterprise applications, and data processing. The simplicity and independence of POJOs make them easy to work with and integrate into different environments.

## Annotations In JAVA
In Java, annotations are a form of metadata that provide data about a program, but they do not affect the program's execution directly. Annotations can be added to Java declarations, including classes, methods, fields, parameters, and other program elements, to provide additional information to the compiler or runtime environment.

Annotations are introduced with an `@` symbol followed by the `annotation name` and optional elements enclosed in parentheses. Java provides built-in annotations as well as the ability to define custom annotations.

### Built-in Annotations in Java:

1. **@Override:**
   - Indicates that a method overrides a `superclass` method.
   - It ensures that the annotated method is actually overriding a method from the superclass. If not, the compiler generates an error.

2. **@Deprecated:**
   - Indicates that a class, method, field, or constructor is `deprecated` and should no longer be used.
   - It informs developers that the annotated element should be avoided because it may be removed in future versions of the API.

3. **@SuppressWarnings:**
   - Instructs the compiler to suppress specific warnings that would normally be generated.
   - It can be applied to classes, methods, fields, and local variables to suppress warnings at various levels.

4. **@FunctionalInterface:**
   - Indicates that an interface is intended to be a functional interface, which can have only one abstract method.
   - It allows the compiler to enforce the single abstract method requirement, and it enables the interface to be used in lambda expressions.

### Custom Annotations:
Java allows developers to define custom annotations by using the `@interface` keyword. Custom annotations can contain elements with default values and can be used to provide additional information specific to an application or framework.

Example of defining a custom annotation:
```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
    String value() default "default value";
    int count() default 0;
}
```

In this example, `@Retention` and `@Target` are meta-annotations used to specify the retention policy (runtime in this case) and target elements (method in this case) for the custom annotation `@MyAnnotation`.

Annotations are processed at compile-time or runtime by tools, frameworks, or libraries to perform tasks such as code analysis, configuration, or code generation. They provide a flexible and powerful mechanism for adding metadata to Java programs and enhancing their functionality.

## The Records In JAVA
In Java, starting from version 14, the Records feature was introduced as a preview feature and became a permanent feature starting from Java 16. Records provide a concise way to declare classes that are meant primarily to store `immutable data`. They offer built-in functionality for defining classes with immutable data fields, transparently implementing common methods like `equals()`, `hashCode()`, and `toString()`, as well as providing a constructor.

Here's a basic overview of records in Java:

### Syntax:
A record declaration looks similar to a class declaration, but it uses the `record` keyword instead of `class`. The record definition includes the record name and a list of components, which are essentially the data fields of the record.

```java
public record Person(String name, int age) {}
```

### Features of Records:

1. **Automatic Accessor Methods:**
   Records `automatically generate accessor methods` (getters) for each component defined in the record declaration. These methods provide read-only access to the data fields.

   ```java
   Person person = new Person("John", 30);
   System.out.println(person.name()); // Accessing the 'name' field
   System.out.println(person.age());  // Accessing the 'age' field
   ```

2. **Immutability:**
   Records are immutable by default, meaning that their state cannot be modified after construction. Once instantiated, the values of the record components cannot be changed.

3. **Automatic toString(), equals(), and hashCode():**
   Records automatically generate `toString()`, `equals()`, and `hashCode()` methods based on the components of the record. These methods provide convenient and consistent behavior for printing, comparing, and hashing record instances.

   ```java
   Person person1 = new Person("John", 30);
   Person person2 = new Person("John", 30);

   System.out.println(person1); // Automatically calls toString()
   System.out.println(person1.equals(person2)); // Automatically compares components
   System.out.println(person1.hashCode()); // Automatically generates a hash code
   ```

4. **Compact Syntax:**
   Records provide a concise syntax for declaring data-holding classes. They reduce boilerplate code and make it easier to define simple classes meant primarily for storing data.

### Limitations:
- `Records cannot extend other classes, but they can implement interfaces.`
- The components of a record cannot be declared as `final`, `volatile`, or `transient`.
- Custom implementations of methods such as `equals()`, `hashCode()`, and `toString()` cannot be provided within the record declaration.

### Use Cases:
- Data Transfer Objects (DTOs)
- Domain Objects
- API Responses
- Tuple-like structures

Records are a valuable addition to the Java language, providing a concise and convenient way to define data-holding classes. They promote immutability and encapsulation while reducing the boilerplate code typically associated with such classes.

## Inharitance In JAVA
Inheritance is a fundamental concept in object-oriented programming (OOP) that allows one class to inherit properties and behaviors (methods and fields) from another class. In Java, classes can be organized into hierarchies through inheritance, creating parent-child relationships where child classes inherit characteristics from their parent classes. Here's an overview of inheritance in Java:

### Superclass and Subclass:
- Inheritance involves two types of classes: `superclass` (parent class) and `subclass` (child class).
- The superclass is the class being inherited from, while the subclass is the class that inherits from the superclass.
- The subclass extends the superclass using the `extends` keyword.

- And a subclass can extends `many` superclasses.

Example of superclass and subclass:
```java
// Superclass
public class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

// Subclass
public class Dog extends Animal, Object {
    public void bark() {
        System.out.println("Dog is barking");
    }
}
```

### Extending Classes:
- A subclass inherits all accessible properties and behaviors (methods and fields) from its superclass.
- The subclass can provide additional methods and fields or `override inherited methods`.

### Access Modifiers and Inheritance:
- Access modifiers (`public`, `protected`, `default`, `private`) control the visibility of superclass members in subclasses.
- Inherited members can be accessed based on their access modifiers:
  - `public` members are accessible to all classes.
  - `protected` members are accessible within the same package or subclasses.
  - `default` members are accessible within the same package only.
  - `private` members are not directly accessible in subclasses.

### Method Overriding:
- Subclasses can override methods inherited from the superclass to provide specialized behavior.
- The method signature (name and parameters) in the subclass must match that of the superclass method.
- Use `@Override` annotation to `indicate` that a method is intended to override a superclass method (optional but recommended).

Example of method overriding:
```java
public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating");
    }

    void callSuperclassMethod() {
        super.eat(); // Call superclass method
    }
}
```

### Constructor Inheritance:
- `Constructors are not inherited by subclasses` but are invoked implicitly when creating instances of subclasses.
- Subclass constructors must explicitly call a superclass constructor using `super()` to initialize `inherited` fields.

`super()` is somewhat like `this()`
like `this()` has to be the first statment of Counstructor.
bcoz of this rule `this()` and `super()` can not be used in same constructor.

In Java, when a subclass constructor is invoked, it implicitly calls(`if you will not call super() than java calls it for you.`) the superclass constructor as its first statement. If the superclass constructor requires arguments, the subclass constructor must explicitly invoke a superclass constructor using the `super()` keyword. Here's an example demonstrating how to invoke the superclass constructor from a subclass constructor:

```java
// Superclass
public class Animal {
    private String name;

    // Superclass constructor with one parameter
    public Animal(String name) {
        this.name = name;
        System.out.println("Animal constructor invoked with name: " + name);
    }

    public void eat() {
        System.out.println("Animal is eating");
    }
}

// Subclass
public class Dog extends Animal {
    private String breed;

    // Subclass constructor with two parameters
    public Dog(String name, String breed) {
        super(name); // Invoking superclass constructor with 'name' argument
        this.breed = breed;
        System.out.println("Dog constructor invoked with breed: " + breed);
    }

    public void bark() {
        System.out.println("Dog is barking");
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        // Creating an instance of Dog
        Dog dog = new Dog("Buddy", "Labrador");
        dog.eat(); // Invoking superclass method
        dog.bark(); // Invoking subclass method
    }
}
```

Output:
```
Animal constructor invoked with name: Buddy
Dog constructor invoked with breed: Labrador
Animal is eating
Dog is barking
```

In the `Dog` subclass, the constructor explicitly calls the superclass constructor using `super(name)` to initialize the `name` field inherited from the `Animal` superclass. This ensures that the superclass constructor is invoked before any subclass-specific initialization logic is executed.


### Object Class:
- Every class in Java is a subclass of the `Object` class, either directly or indirectly.
- The `Object` class provides common methods such as `equals()`, `hashCode()`, `toString()`, etc., which are inherited by all classes.

### Benefits of Inheritance:
- Code Reusability: Inheritance promotes code reuse by allowing subclasses to inherit and extend the functionality of superclasses.
- Polymorphism: Inheritance enables polymorphic behavior, allowing objects of subclasses to be treated as objects of their superclass type.

Inheritance is a powerful mechanism in Java for building hierarchies of related classes and promoting code reuse and polymorphism. It is a key concept in object-oriented design, enabling the creation of modular and extensible software systems.


## Child Object Reffrence In Parent Object Reffrence
In Java, a parent object cannot directly hold a reference to a child object. However, `polymorphism` allows a reference variable of a superclass type to refer to an object of a subclass type. This means that you can assign a reference to a subclass object to a variable of the superclass type. 

Let me illustrate this with an example:

```java
class Animal {
    void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }

    void wagTail() {
        System.out.println("Wagging tail");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // Creating a Dog object and assigning it to an Animal reference
        myAnimal.makeSound(); // Output: Woof!
        // myAnimal.wagTail(); // Compilation Error: Animal does not have a wagTail() method
        
        // Casting back to Dog to call wagTail() method
        if (myAnimal instanceof Dog) {
            Dog myDog = (Dog) myAnimal; // type casting
            myDog.wagTail(); // Output: Wagging tail
        }
    }
}
```

In this example:

- We have a superclass `Animal` with a method `makeSound()`.
- We have a subclass `Dog` that overrides `makeSound()` and adds its own method `wagTail()`.
- In the `main` method, we create a `Dog` object and assign it to an `Animal` reference variable `myAnimal`. This is allowed due to polymorphism.
- We call `makeSound()` using `myAnimal`, and it invokes the overridden `makeSound()` method of `Dog`.
- We cannot call `wagTail()` directly using `myAnimal` because the `Animal` class does not have this method. Attempting to do so would result in a compilation error.
- We can perform a type check (`instanceof`) and cast `myAnimal` back to `Dog` to call `wagTail()`. This is because we know that `myAnimal` actually refers to a `Dog` object.

So, while the parent object cannot directly hold a reference to a child object, it can hold a reference to a child object via polymorphism. However, to access the child-specific methods, you may need to downcast the parent reference to the appropriate subclass type.

## Polymorphism In JAVA
Polymorphism is a fundamental concept in object-oriented programming (OOP) that allows `objects of different classes to be treated as objects of a common superclass type`. It enables code to be written in a more generic and flexible way, promoting code reuse, extensibility, and maintainability. In Java, `polymorphism is achieved primarily through method overriding and inheritance`. Here's an overview of polymorphism in Java:

### Method Overriding:
- Method overriding allows a subclass to provide a specific implementation of a method that is already defined in its superclass.
- The subclass method must have the same name, parameters, and return type as the superclass method.
- The subclass method can have a more specialized behavior than the superclass method.
- The `@Override` annotation is often used to indicate that a method is intended to override a superclass method (optional but recommended).

Example of method overriding:
```java
class Animal {
    void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}
```

### Polymorphic Behavior:
- Polymorphism allows objects of different subclasses to be treated as objects of a common superclass type.
- This enables flexibility in method invocation, as the `actual method called is determined at runtime` based on the type of the object.
- Polymorphism is achieved through method overriding, where the specific subclass implementation of a method is invoked when called through a superclass reference.

Example of polymorphic behavior:
```java
Animal myAnimal = new Dog(); // Polymorphic assignment
myAnimal.makeSound(); // Invokes Dog's makeSound() method
```

### Benefits of Polymorphism:
1. **Code Reusability:** Polymorphism promotes code reuse by allowing methods to be written in a generic way that can operate on objects of different subclasses.
2. **Flexibility:** Polymorphism enables flexibility in method invocation, as the behavior is determined dynamically at runtime based on the actual object type.
3. **Extensibility:** Polymorphism supports easy extension of the codebase by adding new subclasses with specialized behavior without modifying existing code.

### Use Cases:
- Polymorphism is commonly used in scenarios where a method operates on objects of different subclasses, such as in collections, interfaces, and method parameters.
- It is also useful in implementing runtime polymorphic behavior, where the behavior is determined dynamically based on user input or external conditions.

In summary, polymorphism is a powerful concept in Java that enables code to be written in a flexible and reusable manner, allowing objects of different types to be treated uniformly based on their common superclass. It is a key feature of object-oriented programming and plays a central role in designing modular and extensible Java applications.

## java.lang.Object in JAVA
In Java, the `java.lang.Object` class is the root of the class hierarchy. Every class in Java is a direct or indirect subclass of `Object`. This means that every Java object inherits the methods defined in the `Object` class. Here's an overview of the `Object` class in Java:

Read The Java Article -> [DOC ARTICLE](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html)


### Key Features:

1. **Default Superclass:**
   - If a class does not explicitly extend another class, it implicitly inherits from `Object`.
   - For example, if you define a class like `class MyClass { ... }`, `MyClass` implicitly extends `Object`.

2. **Common Methods:**
   - The `Object` class defines several commonly used methods that are inherited by all classes in Java. Some of the most frequently used methods include:
     - `equals(Object obj)`: Compares two objects for equality.
     - `hashCode()`: Returns a hash code value for the object.
     - `toString()`: Returns a string representation of the object.
     - `getClass()`: Returns the runtime class of the object.
     - `clone()`: Creates and returns a copy of the object.

3. **Default Implementation:**
   - The default implementation of `equals()`, `hashCode()`, and `toString()` methods in `Object` class is based on memory addresses and may not be suitable for all classes.
   - It's common practice to override these methods in subclasses to provide meaningful implementations based on the class's state.

4. **Synchronization Methods:**
   - The `Object` class provides methods for synchronization:
     - `wait()`, `wait(long timeout)`, `wait(long timeout, int nanos)`: Causes the current thread to wait until another thread invokes the `notify()` method or the `notifyAll()` method for this object.
     - `notify()`, `notifyAll()`: Wakes up a single waiting thread or all waiting threads on this object.

5. **Memory Management:**
   - The `Object` class is involved in memory management and garbage collection.
   - An object becomes eligible for garbage collection when it no longer has any references.

### Example Usage:

```java
public class MyClass {
    private int id;

    public MyClass(int id) {
        this.id = id;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || getClass() != obj.getClass())
            return false;
        MyClass myObj = (MyClass) obj;
        return id == myObj.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "MyClass{" +
                "id=" + id +
                '}';
    }

    public static void main(String[] args) {
        MyClass obj1 = new MyClass(1);
        MyClass obj2 = new MyClass(2);

        System.out.println(obj1.equals(obj2)); // Output: false
        System.out.println(obj1.hashCode());   // Output: 31
        System.out.println(obj1.toString());   // Output: MyClass{id=1}
    }
}
```

In this example, `MyClass` overrides the `equals()`, `hashCode()`, and `toString()` methods inherited from `Object` to provide custom implementations based on the `id` field of the class.

Overall, the `Object` class plays a central role in Java's class hierarchy, providing essential methods and functionality used by all Java classes.


## This vs Super In JAVA
In Java, `this` and `super` are special keywords used to refer to different things within a class:

### `this` Keyword:
- `this` refers to the `current instance` of the class.
- It is primarily used to:
  - Differentiate between instance variables and parameters with the same name.
  - Invoke constructors from other constructors (constructor chaining).
  - Pass the current object as a parameter to other methods or constructors.
- When used alone, `this` refers to the current object.
- Example usage:
  ```java
  public class MyClass {
      private int value;

      public MyClass(int value) {
          this.value = value; // 'this' distinguishes instance variable from parameter
      }

      public void setValue(int value) {
          this.value = value; // 'this' refers to the instance variable 'value'
      }
  }
  ```

### `super` Keyword:
- `super` refers to the `superclass` of the current object.
- It is primarily used to:
  - Invoke `superclass constructors`.
  - Access `superclass methods` or fields that are overridden in the subclass.
- When used alone, `super` refers to the `superclass object`.
- Example usage:
  ```java
  public class Dog extends Animal {
      public Dog(String name) {
          super(name); // Invokes superclass constructor
      }

      public void printDetails() {
          super.printDetails(); // Calls superclass method
      }
  }
  ```

### Differences:
1. **Reference:**
   - `this` refers to the current object instance.
   - `super` refers to the superclass of the current object.

2. **Usage:**
   - `this` is used to refer to instance variables, methods, or constructors of the current object.
   - `super` is used to refer to superclass constructors, methods, or fields.

3. **Invocation:**
   - `this` is typically used implicitly but can also be used explicitly (e.g., `this.method()`).
   - `super` must be used explicitly (e.g., `super.method()` or `super(args)`).

4. **Context:**
   - `this` is mainly used within instance methods or constructors of a class.
   - `super` is mainly used within subclass constructors or methods to access superclass members or constructors.

In summary, `this` and `super` are both keywords used to refer to different things within a class: `this` refers to the current object instance, while `super` refers to the superclass of the current object. Understanding their differences and when to use them is essential for writing effective Java code.

## Method Overlaoding And Method Overriding 
In Java, method overloading and method overriding are both mechanisms to achieve polymorphism, where different behaviors can be exhibited by objects of the same class. However, they serve different purposes and involve different concepts:

### Method Overloading:

Method overloading refers to defining multiple methods in a class with the same name but with different parameter lists. The compiler differentiates between overloaded methods based on the number, type, and order of their parameters.

#### Characteristics:
1. **Same Method Name:**
   - Overloaded methods have the same name but differ in their parameter lists.

2. **Different Parameter Lists:**
   - Overloaded methods must have different parameter types, a different number of parameters, or a different order of parameters.

3. **Static Binding (Compile-Time Polymorphism):**
   - The selection of which overloaded method to call is determined by the compiler based on the method signature at compile time.

4. **Return Type Doesn't Matter:**
   - Method overloading can have different return types for the same method name.

Example of method overloading:
```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
```

### Method Overriding:

Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method signature (name and parameters) must be the same in both the superclass and the subclass.

#### Characteristics:
1. **Same Method Name and Signature:**
   - Overriding methods have the same name and parameters as the method in the superclass.

2. **Dynamic Binding (Run-Time Polymorphism):**
   - The selection of which overridden method to call is determined by the JVM at runtime, based on the actual type of the object.

3. **Return Type Must Match:**
   - Overridden methods must have the same return type as the method in the superclass, or a covariant return type (a subtype of the return type).

Example of method overriding:
```java
class Animal {
    void makeSound() {
        System.out.println("Generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}
```

### Key Differences:

1. **Purpose:**
   - Method overloading is used to provide multiple methods with the same name but different functionalities.
   - Method overriding is used to provide a specific implementation of a method in a subclass, often to customize behavior.

2. **Inheritance:**
   - Method overloading can occur in the same class or in a subclass.
   - Method overriding occurs in a subclass that inherits from a superclass.

3. **Binding:**
   - Method overloading uses static binding (compile-time polymorphism).
   - Method overriding uses dynamic binding (run-time polymorphism).

Both method overloading and method overriding are important concepts in Java, providing flexibility and extensibility in class design and allowing for polymorphic behavior. Understanding when to use each approach is essential for writing clean and maintainable code.