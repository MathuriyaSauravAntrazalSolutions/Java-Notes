## Java Containers
In Java, containers are data structures used to store and organize elements efficiently. Java provides a rich set of built-in containers in the form of classes and interfaces in the `java.util` package, each tailored to specific use cases. Let's explore some of the most commonly used containers in Java in depth:

### 1. Arrays (`java.util.Arrays`):
- Arrays are `fixed-size` data structures that store elements of the same type in contiguous memory locations.
- They offer constant-time access to elements by index but have a fixed size, making them inflexible for dynamic resizing.
- Arrays can be multidimensional, allowing you to represent data in multiple dimensions, such as matrices or grids.

### 2. ArrayList (`java.util.ArrayList`):
- ArrayList is a resizable array implementation that dynamically adjusts its size as elements are added or removed.
- It offers constant-time access to elements by index and amortized constant-time insertion and removal operations.
- ArrayList is not `synchronized, meaning it's not thread-safe by default,` but it's faster than Vector for single-threaded scenarios.

### 3. LinkedList (`java.util.LinkedList`):
- `LinkedList is a doubly linked list implementation where each element is stored in a node containing references to the previous and next elements`.
- It offers constant-time insertion and removal operations at the beginning and end of the list but linear-time access by index.
- LinkedList is useful for frequent insertion and removal operations but `less efficient for random access`.

### 4. HashSet (`java.util.HashSet`) and TreeSet (`java.util.TreeSet`):
- `HashSet and TreeSet` are implementations of the `Set interface`, representing collections of unique elements with no duplicate values.
- HashSet uses a hash table for storage, providing constant-time average-case performance for basic operations.
- `TreeSet` is implemented as a `Red-Black tree`, maintaining elements in sorted order and providing `log(n) time for most operations`.
- TreeSet is suitable for scenarios requiring sorted data, while HashSet offers better performance for unordered collections.

### 5. HashMap (`java.util.HashMap`) and TreeMap (`java.util.TreeMap`):
- HashMap and TreeMap are implementations of the `Map interface`, representing collections of key-value pairs.
- HashMap uses a hash table for storage, offering constant-time average-case performance for basic operations like put, get, and remove.
- `TreeMap` is implemented as a `Red-Black tree`, maintaining key-value pairs in sorted order by keys and providing `log(n) time for most operations`.
- HashMap is suitable for scenarios requiring fast key-based lookup, while TreeMap offers sorted traversal of key-value pairs.

### 6. Stack (`java.util.Stack`) and Queue (`java.util.Queue`):
- `Stack` is a last-in, first-out (LIFO) data structure, where elements are added and removed from the same end, known as the top.
- `Queue` is a first-in, first-out (FIFO) data structure, where elements are added at the rear and removed from the front.
- Java provides the `LinkedList` class, which `implements both the Stack and Queue interfaces`, allowing you to use it as a stack or queue.

These are some of the core containers in Java, each optimized for different scenarios and use cases. Understanding their characteristics and performance characteristics is essential for choosing the right container for your specific requirements. Additionally, Java's Collections Framework provides a wide range of utility methods and algorithms for working with containers efficiently.

## List In JAVA
In Java, the `List interface` is part of the Collections Framework in the `java.util` package. It represents an ordered collection of elements where each element has an index. Lists allow duplicate elements, and they maintain the insertion order of elements. The `List` interface `extends` the `Collection interface` and adds functionality for accessing elements by index and performing positional operations.

Here are some key characteristics of the `List` interface:

1. **Ordered Collection**: Lists maintain the order of elements in which they are inserted. You can retrieve elements in the same order using their indices.

2. **Duplicates Allowed**: Lists allow duplicate elements. Unlike sets, which enforce uniqueness, lists can contain multiple occurrences of the same element.

3. **Indexed Access**: Elements in a list can be accessed using their index. The index starts from 0 for the first element and goes up to `size() - 1` for the last element.

4. **Positional Operations**: Lists support various positional operations such as adding elements at specific indices, removing elements by index, and replacing elements at specific positions.

The `List` interface defines several methods for manipulating lists, including:

- `add(E element)`: Adds the specified element to the end of the list.
- `add(int index, E element)`: Inserts the specified element at the specified position in the list.
- `remove(int index)`: Removes the element at the specified position in the list.
- `get(int index)`: Returns the element at the specified position in the list.
- `set(int index, E element)`: Replaces the element at the specified position in the list with the specified element.
- `indexOf(Object o)`: Returns the index of the first occurrence of the specified element in the list, or -1 if the list does not contain the element.
- `size()`: Returns the number of elements in the list.
- `isEmpty()`: Returns true if the list contains no elements.

Common `implementations` of the `List` interface in Java include `ArrayList`, `LinkedList`, and `Vector`.

Here's an example demonstrating the usage of the `List` interface with an `ArrayList`:

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Creating an ArrayList
        List<String> list = new ArrayList<>();

        // Adding elements to the list
        list.add("Java");
        list.add("Python");
        list.add("C++");

        // Accessing elements by index
        System.out.println("Element at index 1: " + list.get(1));

        // Iterating through the list
        System.out.println("Elements in the list:");
        for (String element : list) {
            System.out.println(element);
        }
    }
}
```

Output:
```
Element at index 1: Python
Elements in the list:
Java
Python
C++
```

In this example, we create an `ArrayList` and add elements to it using the `add()` method. We then access elements by index using the `get()` method and iterate through the list using a for-each loop.


## List vs ArrayList
In Java, `List` and `ArrayList` are related but distinct concepts:

### List:
- `List` is an `interface` in the `java.util` package.
- It represents an ordered collection of elements, where each element has an index.
- Being an interface, it `cannot be instantiated directly`. Instead, it provides a contract that concrete list implementations must follow.
- It allows duplicate elements and maintains the insertion order of elements.

### ArrayList:
- `ArrayList` is a concrete implementation of the `List` interface.
- It is part of the `java.util` package.
- It uses a `dynamically resizable` array to store elements internally.
- `ArrayList` provides constant-time access to elements by index and amortized constant-time insertion and removal operations at the end of the list.
- It's not `synchronized`, meaning it's not thread-safe by default, but it's faster than `Vector` for single-threaded scenarios.

Here's a summary of the differences between `List` and `ArrayList`:

1. **Interface vs Class**: `List` is an interface, while `ArrayList` is a class that implements the `List` interface.

2. **Instantiation**: You cannot create an instance of `List` directly, but you can create instances of `ArrayList` using its constructors or by using the `List` reference:

   ```java
   List<String> list = new ArrayList<>();
   ```

3. **Resizability**: `ArrayList` is resizable, meaning it can grow or shrink dynamically as elements are added or removed. 
**NOTE:-** `List` doesn't define `resizing behavior` as it's just an interface.
Example as follows:
    - `This is Not Allowed`

    ```java
    import java.util.List;

    public class Main {
        public static void main(String[] args) {
            String[] arr = {"Apple", "Orange", "Rat", "Banana"};
            // of is static method in List Interface
            List<String> list = List.of(arr);
            list.add("Man"); // error
            System.out.println(list); 
        }
    }
    error bcoz this list is not created using ArrayList
    ```
    
    - `This is Allowed`
    
    ```java
    public class Main {
        public static void main(String[] args) {
            String[] arr = {"Apple", "Orange", "Rat", "Banana"};
            List<String> list = List.of(arr);
            // list.add("Man");
            System.out.println(list);

            ArrayList<String> array = new ArrayList<>(list);
            array.add("Man");
            System.out.println(array);
        }
    }
    ```


4. **Performance**: `ArrayList` provides constant-time access to elements by index, making it efficient for random access. However, insertion and removal operations may be slower than `LinkedList` for large lists, especially when performed in the middle of the list.

5. **Thread Safety**: Neither `List` nor `ArrayList` is thread-safe by default. If you need thread-safe behavior, you can use synchronized wrappers like `Collections.synchronizedList()`.

In most cases, you'll use `ArrayList` when you need a dynamically resizable list with fast random access to elements. However, you can also use other implementations of the `List` interface, such as `LinkedList`, `Vector`, or custom implementations, depending on your specific requirements.

## ArrayList Methods Used In JAVA
In Java, the `ArrayList` class provides a wide range of methods for manipulating dynamic arrays. Here are some of the most commonly used methods of the `ArrayList` class:

### 1. Adding Elements:
- `boolean add(E element)`: Appends the specified element to the end of the list.
- `void add(int index, E element)`: Inserts the specified element at the specified position in the list.
- `boolean addAll(Collection<? extends E> collection)`: Appends all elements of the specified collection to the end of the list.
- `boolean addAll(int index, Collection<? extends E> collection)`: Inserts all elements of the specified collection into the list at the specified position.

### 2. Removing Elements:
- `void clear()`: Removes all elements from the list.
- `E remove(int index)`: Removes the element at the specified position in the list and returns it.
- `boolean remove(Object o)`: Removes the first occurrence of the specified element from the list.
- `boolean removeAll(Collection<?> collection)`: Removes all elements from the list that are present in the specified collection.
- `boolean removeIf(Predicate<? super E> filter)`: Removes all elements from the list that satisfy the given predicate.

### 3. Accessing Elements:
- `E get(int index)`: Returns the element at the specified position in the list.
- `E set(int index, E element)`: Replaces the element at the specified position in the list with the specified element.
- `int indexOf(Object o)`: Returns the index of the first occurrence of the specified element in the list.
- `int lastIndexOf(Object o)`: Returns the index of the last occurrence of the specified element in the list.

### 4. Checking Size and Emptyness:
- `int size()`: Returns the number of elements in the list.
- `boolean isEmpty()`: Returns `true` if the list contains no elements.

### 5. Iterating Over Elements:
- `Iterator<E> iterator()`: Returns an iterator over the elements in the list.
- `ListIterator<E> listIterator()`: Returns a list iterator over the elements in the list.
- `void forEach(Consumer<? super E> action)`: Performs the given action for each element of the list.

### 6. Converting to Array:
- `Object[] toArray()`: Returns an array containing all of the elements in the list.
- `T[] toArray(T[] array)`: Returns an array containing all of the elements in the list; the runtime type of the returned array is that of the specified array.

### 7. Sublist Operations:
- `List<E> subList(int fromIndex, int toIndex)`: Returns a view of the portion of the list between the specified `fromIndex`, inclusive, and `toIndex`, exclusive.

### 8. Miscellaneous:
- `void trimToSize()`: Trims the capacity of the underlying array to the current size of the list.
- `void ensureCapacity(int minCapacity)`: Increases the capacity of the underlying array, if necessary, to ensure that it can hold at least the specified number of elements.

These are some of the most commonly used methods of the `ArrayList` class in Java. Understanding and mastering these methods will allow you to efficiently manipulate dynamic arrays in your Java programs.

Here are some commonly used methods of the `ArrayList` class in Java, along with examples:

### 1. Adding Elements:

#### `boolean add(E element)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");
        System.out.println(list); // Output: [Apple, Banana, Orange]
    }
}
```

#### `void add(int index, E element)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Orange");
        list.add(1, "Banana"); // Insert "Banana" at index 1
        System.out.println(list); // Output: [Apple, Banana, Orange]
    }
}
```

#### `boolean addAll(Collection<? extends E> collection)`
```java
import java.util.ArrayList;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.addAll(Arrays.asList("Banana", "Orange"));
        System.out.println(list); // Output: [Apple, Banana, Orange]
    }
}
```

### 2. Removing Elements:

#### `E remove(int index)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        String removed = list.remove(1); // Remove element at index 1 (Banana)
        System.out.println(removed); // Output: Banana
        System.out.println(list); // Output: [Apple, Orange]
    }
}
```

#### `boolean remove(Object o)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        boolean removed = list.remove("Banana"); // Remove "Banana"
        System.out.println(removed); // Output: true
        System.out.println(list); // Output: [Apple, Orange]
    }
}
```

### 3. Accessing Elements:

#### `E get(int index)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        String element = list.get(1); // Get element at index 1
        System.out.println(element); // Output: Banana
    }
}
```

#### `int indexOf(Object o)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        int index = list.indexOf("Banana"); // Get index of "Banana"
        System.out.println(index); // Output: 1
    }
}
```

### 4. Checking Size and Emptyness:

#### `int size()`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        int size = list.size(); // Get size of the list
        System.out.println(size); // Output: 3
    }
}
```

#### `boolean isEmpty()`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        boolean empty = list.isEmpty(); // Check if list is empty
        System.out.println(empty); // Output: true
    }
}
```

These are some of the most commonly used methods of the `ArrayList` class in Java, along with examples demonstrating their usage.

### 5. Iterating Over Elements:

#### `void forEach(Consumer<? super E> action)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        
        // Using lambda expression
        list.forEach(item -> System.out.println(item));

        // Using method reference
        list.forEach(System.out::println);
    }
}
```

#### `Iterator<E> iterator()`
```java
import java.util.ArrayList;
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

### 6. Converting to Array:

#### `Object[] toArray()`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        
        Object[] array = list.toArray();
        System.out.println(Arrays.toString(array)); // Output: [Apple, Banana, Orange]
    }
}
```

#### `T[] toArray(T[] array)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        
        String[] array = list.toArray(new String[list.size()]);
        System.out.println(Arrays.toString(array)); // Output: [Apple, Banana, Orange]
    }
}
```

### 7. Sublist Operations:

#### `List<E> subList(int fromIndex, int toIndex)`
```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
        
        List<String> subList = list.subList(1, 3); // Sublist from index 1 to 2
        System.out.println(subList); // Output: [Banana, Orange]
    }
}
```

### 8. Miscellaneous:

#### `void trimToSize()`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(20); // Initial capacity of 20
        
        // Add elements to the list

        list.trimToSize(); // Trim the capacity to the current size
    }
}
```

#### `void ensureCapacity(int minCapacity)`
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(20); // Initial capacity of 20
        
        // Add elements to the list

        list.ensureCapacity(30); // Ensure the capacity is at least 30
    }
}
```

These are examples of additional methods of the `ArrayList` class in Java, demonstrating their usage in various scenarios.


## Backed by the specified array when using asList(array)
This behavior is due to the fact that the `Arrays.asList()` method returns a fixed-size `List` backed by the original array. When you update the `ArrayList` obtained from `Arrays.asList()`, the changes are reflected in the original array as well.

Here's why this happens:

1. **Fixed-Size List**: The `Arrays.asList()` method returns a `fixed-size` list, which means that you cannot add or remove elements from it. The size of this list is determined by the size of the original array passed to `Arrays.asList()`.

2. **Backed by the Original Array**: The list returned by `Arrays.asList()` is backed by the original array. This means that any changes made to the elements of the list are directly reflected in the original array.

Here's an example to illustrate this behavior:

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        Integer[] array = {1, 2, 3, 4, 5};

        // Create an ArrayList from the array using Arrays.asList()
        List<Integer> list = new ArrayList<>(Arrays.asList(array));

        // Modify the ArrayList
        list.set(0, 10); // Update the first element

        // Print the original array
        System.out.println(Arrays.toString(array)); // Output: [10, 2, 3, 4, 5]
    }
}
```

In this example, we create an `ArrayList` from the array using `Arrays.asList()`. When we modify the `ArrayList` by setting the first element to `10`, the changes are reflected in the original array as well.

To avoid this behavior and create a separate copy of the array, you can create a new `ArrayList` and add elements from the original array individually:

```java
List<Integer> list = new ArrayList<>(Arrays.asList(array));
```

Or you can use `Arrays.copyOf()` or `Arrays.copyOfRange()` to create a copy of the original array before creating the `ArrayList`. This ensures that changes made to the `ArrayList` do not affect the original array.






## List.of() vs Arrays.asList()
Certainly! Let's dive into the descriptions and comparison of `Arrays.asList()` and `List.of()` methods, along with examples:

### Arrays.asList()

- **Description**: `Arrays.asList()` is a method in the `Arrays` class that returns a `fixed-size` list backed by the specified array.
- **Mutability**: The list returned by `Arrays.asList()` is mutable, meaning you can modify its elements.
- **Backing**: Any changes made to the elements of the list are directly reflected in the original array and vice versa.
- **Type Inference**: Type inference is used, so you can create a list of any type by passing an array of that type.
- **Accepts Arrays**: It accepts arrays of any reference type (Object arrays).

**Example**:
```java
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        String[] array = {"A", "B", "C"};
        List<String> list = Arrays.asList(array);

        // Modify the list
        list.set(0, "X");

        // Changes are reflected in the original array
        System.out.println(Arrays.toString(array)); // Output: [X, B, C]
    }
}
```

### List.of()

- **Description**: `List.of()` is a static factory method in the `List` interface introduced in Java 9 that returns an immutable list containing the specified elements.
- **Mutability**: The list returned by `List.of()` is immutable, meaning you cannot modify its elements. Any attempt to modify the list will result in an `UnsupportedOperationException`.
- **Backing**: It does not have an array backing, so changes to the original array do not affect the list, and vice versa.
- **Type Inference**: Type inference is not used, so you need to specify the type of the list explicitly.
- **Element Limit**: It accepts a variable number of arguments and can contain up to 10 elements. If you need more elements, you can use `List.of()` with an `Arrays.copyOf()` or another `List` constructor.

**Note:** this immutable nature is only applicable when you have List<> as reffrence in case of ArrayList it can be mutable


**Example**:
```java
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Immutable List
        List<String> list = List.of("A", "B", "C");

        // Immutable List
        List<String> listArray = new ArrayList<>(List.of("A", "B", "C"));

        // Mutable list
        ArrayList<String> listArray = new ArrayList<>(List.of("A", "B", "C")); 

        // Attempt to modify the list (results in UnsupportedOperationException)
        // list.set(0, "X");

        // Attempt to add an element (results in UnsupportedOperationException)
        // list.add("D");
    }
}
```

### Comparison

- **Mutability**: `Arrays.asList()` returns a mutable list, while `List.of()` returns an immutable list.
- **Backing**: `Arrays.asList()` is backed by the original array, so changes to the list affect the original array. `List.of()` does not have an array backing, so changes to the original array do not affect the list, and vice versa.
- **Null Handling**: `Arrays.asList()` allows `null` elements in the array, while `List.of()` does not allow `null` elements.
- **Type Inference**: `Arrays.asList()` uses type inference, while `List.of()` does not. With `List.of()`, you need to specify the type of the list explicitly.
- **Element Limit**: `Arrays.asList()` can create lists of any size, while `List.of()` has a limit of 10 elements. If you need more elements, you'll have to use other methods or combine `List.of()` with other constructors like `Arrays.copyOf()`.
- **Mutability Requirement**: If you need a mutable list, you can use `Arrays.asList()`. If you need an immutable list, `List.of()` is a better choice for its immutability and lack of array backing.

In summary, `Arrays.asList()` and `List.of()` both serve the purpose of creating lists, but they have different mutability characteristics, handling of `null` elements, and behavior regarding array backing. Choose the appropriate method based on your requirements for mutability and element handling.



## ArrayList Comparator In JAVA
In Java, the `Comparator` interface is used to define custom comparison logic for objects. You can use `Comparator` to sort `ArrayList` or other collections based on custom criteria. Here's how you can use `Comparator` with `ArrayList`:

### 1. Using `Collections.sort()` with `Comparator`
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Sorting in natural order
        Collections.sort(list);
        System.out.println("Sorted in natural order: " + list);

        // Sorting using a custom comparator (in reverse order)
        Collections.sort(list, Comparator.reverseOrder());
        System.out.println("Sorted in reverse order: " + list);
    }
}
```

### 2. Using `ArrayList.sort()` with `Comparator` (Java 8+)
```java
import java.util.ArrayList;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Sorting in natural order
        list.sort(Comparator.naturalOrder());
        System.out.println("Sorted in natural order: " + list);

        // Sorting using a custom comparator (in reverse order)
        list.sort(Comparator.reverseOrder());
        System.out.println("Sorted in reverse order: " + list);
    }
}
```

### 3. Defining Custom Comparator
You can also define your custom comparator to sort objects based on specific criteria. For example:
```java
import java.util.ArrayList;
import java.util.Comparator;

class LengthComparator implements Comparator<String> {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
}

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Sorting based on length using custom comparator
        list.sort(new LengthComparator());
        System.out.println("Sorted based on length: " + list);
    }
}
```

In this example, `LengthComparator` compares strings based on their lengths.

Using `Comparator`, you can sort `ArrayList` or other collections in Java based on various criteria, including natural order, reverse order, or custom comparison logic.


## Multi Dimentional ArrayLists
In Java, you can create a multi-dimensional ArrayList by `nesting ArrayLists within each other`. This allows you to create lists of lists, effectively representing a two-dimensional array or higher-dimensional arrays. Here's how you can create and work with a two-dimensional ArrayList:

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        // Create a two-dimensional ArrayList
        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();

        // Add rows to the matrix
        for (int i = 0; i < 3; i++) {
            ArrayList<Integer> row = new ArrayList<>();
            for (int j = 0; j < 3; j++) {
                // Add elements to each row
                row.add(i * 3 + j);
            }
            // Add the row to the matrix
            matrix.add(row);
        }

        // Print the two-dimensional ArrayList
        for (ArrayList<Integer> row : matrix) {
            for (Integer element : row) {
                System.out.print(element + " ");
            }
            System.out.println();
        }
    }
}
```

In this example:
- We create a two-dimensional ArrayList named `matrix`.
- We add rows to the `matrix` by creating individual ArrayLists for each row and adding them to the `matrix`.
- We populate each row with elements (in this case, sequential integers).
- We print the contents of the two-dimensional ArrayList, resulting in a 3x3 matrix-like structure.

You can extend this concept to create higher-dimensional ArrayLists by nesting additional ArrayLists. For example, you can create a three-dimensional ArrayList by nesting ArrayLists within ArrayLists within ArrayLists, and so on.

Working with multi-dimensional ArrayLists allows for flexible data structures that can represent matrices, tables, or other multi-dimensional data in Java.


## LinkedList In JAVA
In Java, `LinkedList` is a class that implements the `List` interface and provides a doubly linked list data structure. Unlike arrays, which store elements in contiguous memory locations, linked lists store elements as nodes, where each node contains a reference to the next and previous nodes in the sequence.

Here are some key characteristics and features of the `LinkedList` class:

1. **Doubly Linked List**: Each element in a `LinkedList` is stored as a node that contains references to both the next and previous nodes in the sequence. This allows for efficient insertion, removal, and traversal of elements.

2. **Dynamic Size**: Unlike arrays, `LinkedList` does not have a fixed size. It can grow or shrink dynamically as elements are added or removed.

3. **Efficient Insertion and Deletion**: Insertion and deletion operations in a `LinkedList` are generally more efficient than in an array, especially for operations involving elements in the middle of the list.

4. **Random Access**: `LinkedList` does not support efficient random access to elements by index. Accessing an element by index requires traversing the list from the beginning or end, which can be slow for large lists.

5. **Memory Overhead**: Each node in a `LinkedList` consumes additional memory to store references to the next and previous nodes, which can result in higher memory overhead compared to arrays.

6. **Iterators**: `LinkedList` provides iterators to traverse the elements of the list sequentially. These iterators allow for efficient iteration over the elements in both forward and backward directions.

7. **Not Synchronized**: `LinkedList` is not synchronized, meaning it is not thread-safe. If multiple threads need to access a `LinkedList` concurrently, external synchronization is required.

Here's a simple example demonstrating the usage of `LinkedList` in Java:

```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        // Create a LinkedList
        LinkedList<String> linkedList = new LinkedList<>();

        // Add elements to the LinkedList
        linkedList.add("Apple");
        linkedList.add("Banana");
        linkedList.add("Orange");

        // Print the elements of the LinkedList
        for (String fruit : linkedList) {
            System.out.println(fruit);
        }
    }
}
```

In this example, we create a `LinkedList` of strings, add some elements to it, and then iterate over the elements using a for-each loop.

## Methods of LinkedList
The `LinkedList` class in Java provides a variety of methods to manipulate and access elements in a doubly linked list. Here are some commonly used methods of the `LinkedList` class:

### 1. Adding Elements:

- `boolean add(E element)`: Appends the specified element to the end of the list.
- `void add(int index, E element)`: Inserts the specified element at the specified position in the list.
- `boolean addAll(Collection<? extends E> collection)`: Appends all elements of the specified collection to the end of the list.
- `boolean addAll(int index, Collection<? extends E> collection)`: Inserts all elements of the specified collection into the list at the specified position.

### 2. Removing Elements:

- `E remove()`: Removes and returns the first element of the list.
- `boolean remove(Object o)`: Removes the first occurrence of the specified element from the list.
- `E remove(int index)`: Removes and returns the element at the specified position in the list.
- `void clear()`: Removes all elements from the list.

### 3. Accessing Elements:

- `E getFirst()`: Returns the first element in the list.
- `E getLast()`: Returns the last element in the list.
- `E get(int index)`: Returns the element at the specified position in the list.

### 4. Checking Size and Emptyness:

- `int size()`: Returns the number of elements in the list.
- `boolean isEmpty()`: Returns `true` if the list contains no elements.

### 5. Iterating Over Elements:

- `Iterator<E> iterator()`: Returns an iterator over the elements in the list.
- `ListIterator<E> listIterator()`: Returns a list iterator over the elements in the list.

### 6. Searching and Checking for Elements:

- `boolean contains(Object o)`: Returns `true` if the list contains the specified element.
- `int indexOf(Object o)`: Returns the index of the first occurrence of the specified element in the list.
- `int lastIndexOf(Object o)`: Returns the index of the last occurrence of the specified element in the list.

### 7. Miscellaneous:

- `void sort(Comparator<? super E> c)`: Sorts the elements of the list according to the specified comparator.
- `void forEach(Consumer<? super E> action)`: Performs the given action for each element of the list.

These are some of the commonly used methods provided by the `LinkedList` class in Java. Understanding and mastering these methods will allow you to efficiently manipulate linked lists in your Java programs.

```java
package dev.lpa;

import java.util.LinkedList;
import java.util.ListIterator;

public class Main {

    public static void main(String[] args) {

//        LinkedList<String> placesToVisit = new LinkedList<>();
        var placesToVisit = new LinkedList<String>();

        placesToVisit.add("Sydney");
        placesToVisit.add(0, "Canberra");
        System.out.println(placesToVisit);

        addMoreElements(placesToVisit);
        System.out.println(placesToVisit);

//        removeElements(placesToVisit);
//        System.out.println(placesToVisit);

//        gettingElements(placesToVisit);

        printItinerary3(placesToVisit);

    }

    private static void addMoreElements(LinkedList<String> list) {

        list.addFirst("Darwin");
        list.addLast("Hobart");
        // Queue methods
        list.offer("Melbourne");
        list.offerFirst("Brisbane");
        list.offerLast("Toowoomba");
        // Stack Methods
        list.push("Alice Springs");

    }

    private static void removeElements(LinkedList<String> list) {

        list.remove(4);
        list.remove("Brisbane");

        System.out.println(list);
        String s1 = list.remove(); // removes first element
        System.out.println(s1 + " was removed");

        String s2 = list.removeFirst(); // removes first element
        System.out.println(s2 + " was removed");

        String s3 = list.removeLast(); // removes last element
        System.out.println(s3 + " was removed");
        // Queue/Deque poll methods
        String p1 = list.poll();  // removes first element
        System.out.println(p1 + " was removed");
        String p2 = list.pollFirst();  // removes first element
        System.out.println(p2 + " was removed");
        String p3 = list.pollLast();  // removes last element
        System.out.println(p3 + " was removed");

        list.push("Sydney");
        list.push("Brisbane");
        list.push("Canberra");
        System.out.println(list);

        String p4 = list.pop();  // removes first element
        System.out.println(p4 + " was removed");
    }

    private static void gettingElements(LinkedList<String> list) {

        System.out.println("Retrieved Element = " + list.get(4));

        System.out.println("First Element = " + list.getFirst());
        System.out.println("Last Element = " + list.getLast());

        System.out.println("Darwin is at position: " + list.indexOf("Darwin"));
        System.out.println("Melbourne is at position: " +
                list.lastIndexOf("Melbourne"));
        // Queue retrieval method
        System.out.println("Element from element() = " + list.element());
        // Stack retrieval methods
        System.out.println("Element from peek() = " + list.peek());
        System.out.println("Element from peekFirst() = " + list.peekFirst());
        System.out.println("Element from peekLast() = " + list.peekLast());
    }

    public static void printItinerary(LinkedList<String> list) {

        System.out.println("Trip starts at " + list.getFirst());
        for (int i = 1; i < list.size(); i++) {
            System.out.println("--> From: " + list.get(i - 1) + " to " + list.get(i));
        }
        System.out.println("Trip ends at " + list.getLast());
    }

    public static void printItinerary2(LinkedList<String> list) {

        System.out.println("Trip starts at " + list.getFirst());
        String previousTown = list.getFirst();
        for (String town : list) {
            System.out.println("--> From: " + previousTown + " to " + town);
            previousTown = town;
        }

        System.out.println("Trip ends at " + list.getLast());
    }

    public static void printItinerary3(LinkedList<String> list) {

        System.out.println("Trip starts at " + list.getFirst());
        String previousTown = list.getFirst();
        // it is list iterator not iterator
        ListIterator<String> iterator = list.listIterator(1);
        while (iterator.hasNext()) {
            var town = iterator.next();
            System.out.println("--> From: " + previousTown + " to " + town);
            previousTown = town;
        }

        System.out.println("Trip ends at " + list.getLast());
    }
}


```


## Iterators In Java
In Java, iterators are objects that provide a way to traverse or iterate over elements in a collection sequentially. Iterators allow you to access elements of a collection one by one, without exposing the underlying implementation of the collection. They are widely used in Java Collections Framework to iterate over collections such as lists, sets, and maps.

The primary interfaces for iterators in Java are:

1. **Iterator**: This interface provides methods for iterating over elements in a collection sequentially. It allows you to check if there are more elements available, retrieve the next element, and remove elements from the underlying collection.

2. **ListIterator**: This interface extends the `Iterator` interface and provides additional functionality for iterating over lists. It allows bidirectional traversal of a list, enabling you to traverse the list forwards and backwards, as well as modify elements during traversal.

Here's a brief overview of the key methods provided by these iterator interfaces:

### Iterator Interface Methods:

- `boolean hasNext()`: Returns `true` if there are more elements in the iteration.
- `E next()`: Returns the next element in the iteration.
- `void remove()`: Removes the last element returned by the iterator from the underlying collection. This method is optional and may not be supported by all iterators.

### ListIterator Interface Methods:

- `boolean hasNext()`: Returns `true` if there are more elements in the list.
- `E next()`: Returns the next element in the list.
- `boolean hasPrevious()`: Returns `true` if there are more elements in the list preceding the current position.
- `E previous()`: Returns the previous element in the list.
- `int nextIndex()`: Returns the index of the element that would be returned by a subsequent call to `next()`.
- `int previousIndex()`: Returns the index of the element that would be returned by a subsequent call to `previous()`.
- `void remove()`: Removes the last element returned by the iterator from the underlying list.
- `void set(E e)`: Replaces the last element returned by the iterator with the specified element.
- `void add(E e)`: Inserts the specified element into the list at the current position of the iterator.

Here's a simple example demonstrating the usage of iterators in Java:

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Using Iterator to iterate over the list
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String element = iterator.next();
            System.out.println(element);
        }
    }
}
```

In this example, we create an `ArrayList` of strings, add elements to it, and then use an iterator to iterate over the elements of the list sequentially. We check if there are more elements using `hasNext()` and retrieve each element using `next()`.

```java
package dev.lpa;

import java.util.LinkedList;
import java.util.ListIterator;

public class Main {

    public static void main(String[] args) {

//        LinkedList<String> placesToVisit = new LinkedList<>();
        var placesToVisit = new LinkedList<String>();

        placesToVisit.add("Sydney");
        placesToVisit.add(0, "Canberra");
        System.out.println(placesToVisit);

        addMoreElements(placesToVisit);
        System.out.println(placesToVisit);

//        removeElements(placesToVisit);
//        System.out.println(placesToVisit);

//        gettingElements(placesToVisit);

//        printItinerary3(placesToVisit);

        testIterator(placesToVisit);

    }

    private static void addMoreElements(LinkedList<String> list) {

        list.addFirst("Darwin");
        list.addLast("Hobart");
        // Queue methods
        list.offer("Melbourne");
        list.offerFirst("Brisbane");
        list.offerLast("Toowoomba");
        // Stack Methods
        list.push("Alice Springs");

    }

    private static void removeElements(LinkedList<String> list) {

        list.remove(4);
        list.remove("Brisbane");

        System.out.println(list);
        String s1 = list.remove(); // removes first element
        System.out.println(s1 + " was removed");

        String s2 = list.removeFirst(); // removes first element
        System.out.println(s2 + " was removed");

        String s3 = list.removeLast(); // removes last element
        System.out.println(s3 + " was removed");
        // Queue/Deque poll methods
        String p1 = list.poll();  // removes first element
        System.out.println(p1 + " was removed");
        String p2 = list.pollFirst();  // removes first element
        System.out.println(p2 + " was removed");
        String p3 = list.pollLast();  // removes last element
        System.out.println(p3 + " was removed");

        list.push("Sydney");
        list.push("Brisbane");
        list.push("Canberra");
        System.out.println(list);

        String p4 = list.pop();  // removes first element
        System.out.println(p4 + " was removed");
    }

    private static void gettingElements(LinkedList<String> list) {

        System.out.println("Retrieved Element = " + list.get(4));

        System.out.println("First Element = " + list.getFirst());
        System.out.println("Last Element = " + list.getLast());

        System.out.println("Darwin is at position: " + list.indexOf("Darwin"));
        System.out.println("Melbourne is at position: " +
                list.lastIndexOf("Melbourne"));
        // Queue retrieval method
        System.out.println("Element from element() = " + list.element());
        // Stack retrieval methods
        System.out.println("Element from peek() = " + list.peek());
        System.out.println("Element from peekFirst() = " + list.peekFirst());
        System.out.println("Element from peekLast() = " + list.peekLast());
    }

    public static void printItinerary(LinkedList<String> list) {

        System.out.println("Trip starts at " + list.getFirst());
        for (int i = 1; i < list.size(); i++) {
            System.out.println("--> From: " + list.get(i - 1) + " to " + list.get(i));
        }
        System.out.println("Trip ends at " + list.getLast());
    }

    public static void printItinerary2(LinkedList<String> list) {

        System.out.println("Trip starts at " + list.getFirst());
        String previousTown = list.getFirst();
        for (String town : list) {
            System.out.println("--> From: " + previousTown + " to " + town);
            previousTown = town;
        }

        System.out.println("Trip ends at " + list.getLast());
    }

    public static void printItinerary3(LinkedList<String> list) {

        System.out.println("Trip starts at " + list.getFirst());
        String previousTown = list.getFirst();
        ListIterator<String> iterator = list.listIterator(1);
        while (iterator.hasNext()) {
            var town = iterator.next();
            System.out.println("--> From: " + previousTown + " to " + town);
            previousTown = town;
        }

        System.out.println("Trip ends at " + list.getLast());
    }

    private static void testIterator(LinkedList<String> list) {

        var iterator = list.listIterator();
        while (iterator.hasNext()) {
//            System.out.println(iterator.next());
            if (iterator.next().equals("Brisbane")) {
                iterator.add("Lake Wivenhoe");
            }
        }
        while (iterator.hasPrevious()) {
            System.out.println(iterator.previous());
        }

        System.out.println(list);

        var iterator2 = list.listIterator(3);
        System.out.println(iterator2.previous());

    }
}


```


## Boxing and Un-Boxing in JAVA
Boxing and unboxing in Java refer to the automatic conversion between primitive data types and their corresponding wrapper classes. There are two types of boxing and unboxing: automatic (auto) and manual.

### Automatic Boxing and Unboxing (Auto):

Automatic boxing and unboxing were introduced in Java 5 to simplify the use of primitive types and their corresponding wrapper classes.

#### Boxing (Auto):
```java
// Automatic boxing: converting primitive int to Integer object
int primitiveInt = 42;
Integer wrappedInt = primitiveInt; // Autoboxing

// Automatic boxing: converting primitive double to Double object
double primitiveDouble = 3.14;
Double wrappedDouble = primitiveDouble; // Autoboxing
```

#### Unboxing (Auto):
```java
// Automatic unboxing: converting Integer object to primitive int
Integer wrappedInt = new Integer(42);
int primitiveInt = wrappedInt; // Auto-unboxing

// Automatic unboxing: converting Double object to primitive double
Double wrappedDouble = new Double(3.14);
double primitiveDouble = wrappedDouble; // Auto-unboxing
```

### Manual Boxing and Unboxing:

Manual boxing and unboxing involve explicit conversion between primitive types and their corresponding wrapper classes using constructor or methods.

#### Manual Boxing:
```java
// Manual boxing: converting primitive int to Integer object
int primitiveInt = 42;
Integer wrappedInt = Integer.valueOf(primitiveInt); // Manual boxing

// Manual boxing: converting primitive double to Double object
double primitiveDouble = 3.14;
Double wrappedDouble = Double.valueOf(primitiveDouble); // Manual boxing
```

#### Manual Unboxing:
```java
// Manual unboxing: converting Integer object to primitive int
Integer wrappedInt = new Integer(42);
int primitiveInt = wrappedInt.intValue(); // Manual unboxing

// Manual unboxing: converting Double object to primitive double
Double wrappedDouble = new Double(3.14);
double primitiveDouble = wrappedDouble.doubleValue(); // Manual unboxing
```

### Method Parameters and Return Types:

Automatic boxing and unboxing also occur automatically when passing arguments to methods or returning values from methods.

#### Automatic Boxing in Method Parameters:
```java
// Automatic boxing: converting primitive int to Integer object
printNumber(42); // Autoboxing

// Method accepting Integer object (boxing)
public static void printNumber(Integer number) {
    System.out.println("Number: " + number);
}
```

#### Automatic Unboxing in Method Return Types:
```java
// Automatic unboxing: converting Integer object to primitive int
int result = calculateSum(new Integer(10), new Integer(20)); // Auto-unboxing
System.out.println("Sum: " + result);

// Method returning int (unboxing)
public static int calculateSum(Integer num1, Integer num2) {
    return num1 + num2;
}
```

In summary, automatic boxing and unboxing in Java simplify the code by allowing seamless conversion between primitive types and their wrapper classes, improving readability and reducing the need for explicit conversions.

```java

package dev.lpa;

public class Main {

    public static void main(String[] args) {

        Integer boxedInt = Integer.valueOf(15);      // preferred but unnecessary
        Integer deprecatedBoxing = new Integer(15);  // deprecated since JDK 9
        int unboxedInt = boxedInt.intValue();        // unnecessary

        // Automatic
        Integer autoBoxed = 15;
        int autoUnboxed = autoBoxed;
        System.out.println(autoBoxed.getClass().getName());
//        System.out.println(autoUnboxed.getClass().getName());

        Double resultBoxed = getLiteralDoublePrimitive();
        double resultUnboxed = getDoubleObject();

    }

    private static Double getDoubleObject() {

        return Double.valueOf(100.00);
    }

    private static double getLiteralDoublePrimitive() {

        return 100.0;
    }
}

```


## Boxing and Un-Boxing Related To Arrays
In Java, boxing and unboxing can also occur in the context of arrays. This means converting between primitive types and their corresponding wrapper classes when dealing with arrays. There are scenarios where this conversion happens automatically (auto) and others where it needs to be done manually.

### Auto Boxing/Unboxing in Array Initialization:

Auto boxing/unboxing occurs automatically when you initialize an array with primitive values or their corresponding wrapper class objects.

#### Auto Boxing:

```java
// Auto boxing: primitive values to wrapper class objects
Integer[] integerArray = {1, 2, 3, 4, 5}; // Auto boxing
```

#### Auto Unboxing:

```java
// Auto unboxing: wrapper class objects to primitive values
int[] intArray = {new Integer(1), new Integer(2), new Integer(3)}; // Auto unboxing
```

### Manual Boxing/Unboxing in Array Assignment:

In some cases, you might need to manually convert between primitive types and their wrapper classes when assigning elements to array indices.

#### Manual Boxing:

```java
// Manual boxing: primitive values to wrapper class objects
Integer[] integerArray = new Integer[5];
for (int i = 0; i < integerArray.length; i++) {
    integerArray[i] = Integer.valueOf(i + 1); // Manual boxing
}
```

#### Manual Unboxing:

```java
// Manual unboxing: wrapper class objects to primitive values
int[] intArray = new int[3];
Integer[] integerArray = {1, 2, 3};
for (int i = 0; i < intArray.length; i++) {
    intArray[i] = integerArray[i].intValue(); // Manual unboxing
}
```

### Complete Example:

Here's a complete example illustrating both auto and manual boxing/unboxing in arrays:

```java
public class Main {
    public static void main(String[] args) {
        // Auto boxing: primitive values to wrapper class objects
        Integer[] integerArray1 = {1, 2, 3, 4, 5}; // Auto boxing
        
        // Manual boxing: primitive values to wrapper class objects
        Integer[] integerArray2 = new Integer[5];
        for (int i = 0; i < integerArray2.length; i++) {
            integerArray2[i] = Integer.valueOf(i + 1); // Manual boxing
        }

        // Auto unboxing: wrapper class objects to primitive values
        int[] intArray1 = {new Integer(1), new Integer(2), new Integer(3)}; // Auto unboxing
        
        // Manual unboxing: wrapper class objects to primitive values
        int[] intArray2 = new int[3];
        Integer[] integerArray3 = {1, 2, 3};
        for (int i = 0; i < intArray2.length; i++) {
            intArray2[i] = integerArray3[i].intValue(); // Manual unboxing
        }
    }
}
```

In this example:
- Auto boxing occurs when initializing `integerArray1`.
- Manual boxing is performed in the loop to initialize `integerArray2`.
- Auto unboxing occurs when initializing `intArray1`.
- Manual unboxing is performed in the loop to initialize `intArray2`.



## Enumeration In JAVA
In Java, an enum type (short for enumeration) is a special data type that represents a fixed set of constants. Enums are used to define a collection of related named constants, making the code more readable, maintainable, and type-safe. Each constant in an enum type is an instance of the enum itself.

### Properties of Enum Types:

1. **Constants**: Enum types define a fixed set of named constants, which are instances of the enum type itself.
   
2. **Type Safety**: Enums provide type safety, meaning that you can only assign values that belong to the defined set of constants.

3. **Immutability**: Enum constants are by default immutable and can't be modified once they are created.

4. **Iteration**: Enums can be iterated over using the `values()` method, which returns an array containing all the enum constants in the order they are declared.

5. **Member Methods:** Enum Constant can access methods(kind of object-method binding of classes).

### Methods of Enum Types:
0. **this keyword:** Enum also has `this` keyword.

1. **name()**: Returns the name of the enum constant as a string.

2. **ordinal()**: Returns the ordinal (position) of the enum constant, starting from 0.

3. **valueOf(String name)**: Returns the enum constant with the specified name. Throws an IllegalArgumentException if the specified name is not found.

Here's an example illustrating the properties and methods of enum types:

```java
public class Main {
    enum Day {
        SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
    }

    public static void main(String[] args) {
        // Accessing enum constants
        Day today = Day.MONDAY;
        System.out.println("Today is " + today.name()); // Output: MONDAY
        System.out.println("Ordinal value of today: " + today.ordinal()); // Output: 1

        // Iterating over enum constants
        Day[] days = Day.values();
        for (Day day : days) {
            System.out.println(day);
        }

        // Retrieving enum constant by name
        Day holiday = Day.valueOf("SATURDAY");
        System.out.println("Holiday is " + holiday); // Output: SATURDAY
    }
}
```

In this example:
- We define an enum type `Day` with constants representing days of the week.
- We access the properties of enum constants (`name()` and `ordinal()`).
- We iterate over all enum constants using `values()`.
- We retrieve an enum constant by name using `valueOf()`.


```java
import java.util.Random;

public class Main {
    enum DayOfTheWeek {

        SUN, MON, TUES, WED, THURS, FRI, SAT;
    }


    enum Topping {

        MUSTARD,
        PICKLES,
        BACON,
        CHEDDAR,
        TOMATO;

        public double getPrice() {

            return switch (this) {
                case BACON -> 1.5;
                case CHEDDAR -> 1.0;
                default -> 0.0;
            };
        }
    }


    public static void main(String[] args) {

        DayOfTheWeek weekDay = DayOfTheWeek.TUES;
        System.out.println(weekDay);

        for (int i = 0; i < 10; i++ ) {
            weekDay = getRandomDay();

//            System.out.printf("Name is %s, Ordinal Value = %d%n",
//                    weekDay.name(), weekDay.ordinal());
//
//            if (weekDay == DayOfTheWeek.FRI) {
//                System.out.println("Found a Friday!!!");
//            }

            switchDayOfWeek(weekDay);
        }

        for (Topping topping : Topping.values()) {
            System.out.println(topping.name() + " : " + topping.getPrice());
        }

    }

    public static void switchDayOfWeek(DayOfTheWeek weekDay) {

        int weekDayInteger = weekDay.ordinal() + 1;
        switch (weekDay) {
            case WED -> System.out.println("Wednesday is Day " + weekDayInteger);
            case SAT -> System.out.println("Saturday is Day " + weekDayInteger);
            default -> System.out.println(weekDay.name().charAt(0) +
                    weekDay.name().substring(1).toLowerCase() +
                    "day is Day " + weekDayInteger);
        }
    }

    public static DayOfTheWeek getRandomDay() {

        int randomInteger = new Random().nextInt(7);
        var allDays = DayOfTheWeek.values();

        return allDays[randomInteger];
    }

}

```

#### Constructor Of Enum
In Enums the Cunstructor will be called for every Constant Variable defined in enum when you create a Object Of Enum

```java

public enum Day{
    MONDAY, SUNDAY, SATURDAY;

    Day(){
        System.out.println("the called Constant is: "+ this);
    }
}

class Main{
    public static void main(String[] args){
        Day day = Day.MONDAY;
    }
}

/* Output of this program
the called Constant is: MONDAY
the called Constant is: SUNDAY
the called Constant is: SATURDAY
*/
```


In Java, when you define an enum, the constructor for each enum constant is called during the initialization of the enum type. This happens because each enum constant represents an instance of the enum type, and Java ensures that each constant is properly initialized.

The constructor for an enum is called once for each enum constant when the enum type is loaded by the JVM. This initialization process ensures that each enum constant has its own unique state and behavior, as defined by the enum constant itself or by methods within the enum type.

Here's a breakdown of why the constructor is called for every constant:

1. **Enum Constants as Instances**: Each enum constant in Java is treated as an instance of the enum type. This means that when you define an enum with constants, you're effectively defining multiple instances of that enum type.

2. **Initialization During Type Initialization**: When the enum type is loaded by the JVM (typically when the class containing the enum is first referenced in the code), Java ensures that each enum constant is properly initialized. This includes calling the constructor for each constant to initialize its state.

3. **Ensuring Unique State for Constants**: Since enum constants can have their own unique state (such as fields and methods), calling the constructor for each constant ensures that each constant has its own separate instance with its own state.

4. **Custom Initialization Logic**: If you define a constructor for the enum type, you can provide custom initialization logic for each enum constant. This allows you to initialize fields, set up state, or perform any other necessary initialization tasks specific to each constant.

Here's a simplified example to illustrate the concept:

```java
enum Color {
    RED, GREEN, BLUE; // Enum constants

    private Color() {
        System.out.println("Initializing " + this.name() + " constant");
    }
}

public class Main {
    public static void main(String[] args) {
        Color.RED.toString(); // Trigger enum initialization
    }
}
```

In this example, when the `main` method is executed and the `Color` enum is initialized, the constructor for each enum constant (`RED`, `GREEN`, `BLUE`) is called, resulting in the corresponding output indicating the initialization of each constant.