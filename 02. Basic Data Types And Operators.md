## First Program
* open cmd and initialize JShell using Command `jshell`.
* use this `statement` `System.out.print("Hello World!");` Bingo You have written your First Program In Java.
* here `"hello world!"` is a string literal and always use `""` for string literals and `''` for character literal.

### What is statement??
statement is a complete command to be executed can include one or more `expression` will talk about expression in next chapter.


### Keywords In Java
Keywords in Java are reserved words that have predefined meanings and cannot be used as identifiers (such as variable names, class names, method names, etc.) in Java programs. These keywords are part of the language syntax and serve specific purposes in defining the structure and behavior of Java programs. Here's an overview of the keywords in Java:

1. **abstract**: Used to declare abstract classes and methods. Abstract classes cannot be instantiated, and abstract methods must be implemented by subclasses.

2. **assert**: Used to perform assertions in the code. It's typically used for debugging purposes to check the correctness of certain conditions.

3. **boolean**: Represents a boolean type with values true and false.

4. **break**: Used to terminate the execution of a loop or switch statement.

5. **byte**: Represents an 8-bit signed integer type.

6. **case**: Used within switch statements to define different cases.

7. **catch**: Used to catch exceptions that are thrown during program execution.

8. **char**: Represents a 16-bit Unicode character.

9. **class**: Used to declare a class.

10. **const** (not used): Reserved for future use. It was intended to declare constants, but it's not implemented in Java.

11. **continue**: Used to skip the current iteration of a loop and continue to the next iteration.

12. **default**: Used within switch statements to define the default case.

13. **do**: Used to start a do-while loop.

14. **double**: Represents a double-precision 64-bit floating-point type.

15. **else**: Used in conjunction with if statements to define an alternative path of execution.

16. **enum**: Used to define enumerated types. Introduced in Java 5.

17. **extends**: Used to indicate inheritance in class declarations.

18. **final**: Used to declare constants, make classes not extendable, and make methods not overrideable.

19. **finally**: Used in exception handling to define a block of code that will always be executed, regardless of whether an exception is thrown or caught.

20. **float**: Represents a single-precision 32-bit floating-point type.

21. **for**: Used to start a for loop.

22. **goto** (not used): Reserved for future use. It's not implemented in Java and cannot be used.

23. **if**: Used to start an if statement.

24. **implements**: Used to indicate that a class implements an interface.

25. **import**: Used to import classes or entire packages into the current source file.

26. **instanceof**: Used to test if an object is an instance of a particular class or interface.

27. **int**: Represents a 32-bit signed integer type.

28. **interface**: Used to declare an interface.

29. **long**: Represents a 64-bit signed integer type.

30. **native**: Used to specify that a method is implemented in native code, typically written in another programming language like C or C++.

31. **new**: Used to create new objects.

32. **null**: Represents a null reference, which indicates that a reference variable does not refer to any object.

33. **package**: Used to declare a package, which is a namespace that organizes a set of related classes and interfaces.

34. **private**: Access modifier used to restrict access to members within the same class.

35. **protected**: Access modifier used to allow access to members within the same package or subclasses.

36. **public**: Access modifier used to allow unrestricted access to members.

37. **return**: Used to return a value from a method.

38. **short**: Represents a 16-bit signed integer type.

39. **static**: Used to declare members (fields and methods) that belong to the class rather than to instances of the class.

40. **strictfp**: Used to restrict floating-point calculations to ensure portability.

41. **super**: Used to refer to the superclass of the current object.

42. **switch**: Used to start a switch statement.

43. **synchronized**: Used to control access to methods or blocks of code by multiple threads.

44. **this**: Used to refer to the current object within its own instance method.

45. **throw**: Used to explicitly throw an exception.

46. **throws**: Used in method declarations to indicate the exceptions that the method may throw.

47. **transient**: Used to indicate that a field should not be serialized when the object is serialized.

48. **try**: Used to start a block of code in which exceptions may occur, followed by one or more catch blocks and optionally a finally block.

49. **void**: Used to declare that a method does not return any value.

50. **volatile**: Used to indicate that a variable may be modified asynchronously by multiple threads.

These keywords form the foundation of Java syntax and are essential for writing Java programs. Understanding their meanings and proper usage is crucial for effective Java programming.

## Variables In Java
In Java, variables are containers that hold data which can be manipulated and referenced in a program. They are fundamental building blocks for storing and managing information within a program. Each variable has a specific data type, which determines the type of data it can hold (e.g., integers, floating-point numbers, characters, etc.), and a unique name that identifies it within the scope of the program.

There are three main types of variables in Java:

1. **Local Variables**: These are declared within a method, constructor, or block and can only be accessed within the scope in which they are declared. Local variables must be initialized before they are used.

   ```java
   public void exampleMethod() {
       int localVar = 10; // Declaration and initialization of a local variable
       // localVar is accessible only within this method
       // Other code...
   }
   ```

2. **Instance Variables (Non-Static Fields)**: These are declared within a class but outside of any method, constructor, or block. They are initialized when an object of the class is created and exist for the lifetime of the object.

   ```java
   public class ExampleClass {
       int instanceVar; // Declaration of an instance variable

       public ExampleClass() {
           instanceVar = 20; // Initialization of the instance variable
       }
   }
   ```

3. **Class Variables (Static Fields)**: These are also declared within a class but are marked with the `static` keyword. They belong to the class rather than any specific instance of the class. They are initialized only once when the class is loaded and are shared among all instances of the class.

   ```java
   public class ExampleClass {
       static int classVar = 30; // Declaration and initialization of a class variable
   }
   ```

Variables in Java must be declared before they are used. The declaration typically includes the variable's data type followed by its name. It's important to note that Java is a statically-typed language, meaning that you must explicitly specify the data type of a variable at the time of declaration. Additionally, variables can be modified (assigned new values) throughout the program's execution, allowing for dynamic behavior and data manipulation.

## What is Expression In Java??
In Java, an expression is a combination of variables, operators, method invocations, and literals that can be evaluated to produce a value. Expressions can be simple or complex, depending on the elements they contain and the operations performed on those elements.

Basically en expression is a code segement which is on right side of equals sign in an assignment or declaration statement.

Here are some examples of expressions in Java:

1. Arithmetic Expressions:
   ```java
   int a = 5;
   int b = 3;
   int sum = a + b; // Addition expression
   int product = a * b; // Multiplication expression
   ```

2. Boolean Expressions:
   ```java
   boolean isGreaterThan = a > b; // Greater than expression
   boolean isEqual = a == b; // Equality expression
   ```

3. Method Call Expressions:
   ```java
   String greeting = "Hello";
   int length = greeting.length(); // Method invocation expression
   ```

4. Conditional Expressions:
   ```java
   int max = (a > b) ? a : b; // Ternary conditional expression
   ```

5. Assignment Expressions:
   ```java
   int c = a + b; // Assignment expression
   ```

6. Instance Creation Expressions (New Expressions):
   ```java
   MyClass obj = new MyClass(); // Instance creation expression
   ```

Expressions are used extensively in Java to perform computations, make decisions, and manipulate data. They can appear in various contexts such as variable initialization, method parameters, conditional statements, loop conditions, and more. Additionally, expressions can be nested within other expressions to create more complex behavior.

## Java is Case Sensetive
In Java, being case-sensitive means that identifiers such as variable names, method names, class names, and keywords must be written with consistent capitalization throughout the code. This means that Java considers "Variable", "variable", and "vArIaBlE" to be distinct identifiers.

Here's an overview of how case sensitivity works in Java with examples:

1. **Identifiers**: Variable names, method names, class names, and labels are all case-sensitive.

   ```java
   int myVariable = 10;
   int MyVariable = 20;
   // These two variables are different because of case sensitivity
   ```

2. **Keywords**: Java has a set of reserved words (keywords) that have predefined meanings and cannot be used as identifiers. These keywords are case-sensitive.

   ```java
   int class = 5; // "class" is a keyword and cannot be used as a variable name
   ```

3. **Class names**: Class names must be written exactly as they are declared. This includes both the class name itself and its usage when creating objects.

   ```java
   class MyClass { ... }
   MyClass myObj = new MyClass();
   // "MyClass" must be written with the same capitalization throughout
   ```

4. **Method names**: Similarly, method names must maintain consistent capitalization.

   ```java
   public void myMethod() { ... }
   public void mymethod() { ... }
   // These are considered different methods due to the difference in case
   ```

5. **Package names**: Package names in Java are also case-sensitive.

   ```java
   package com.example.mypackage;
   import com.example.MyPackage; // This import statement is incorrect due to case sensitivity
   ```

6. **File names**: Java source files must have a name that matches the class name contained within, including case sensitivity.

   ```java
   // MyClass.java
   public class MyClass { ... }
   ```

7. **String literals**: String literals, unlike identifiers, are case-sensitive.

   ```java
   String myString = "Hello";
   System.out.println(myString); // Output: Hello
   System.out.println(mystring); // This would result in a compilation error
   ```

Understanding and adhering to Java's case sensitivity rules is crucial for writing error-free and maintainable code. Mixing cases in identifiers or keywords can lead to compilation errors or unexpected behavior.


## Primitive Data Types In Java
In Java, primitive data types are the most basic data types provided by the language. They are used to represent simple values and are not objects. Java has eight primitive data types, which are divided into four categories: integers, floating-point numbers, characters, and boolean values. Here's an overview of each primitive data type:

1. **Integers**:
   - `byte`: `8-bit or 1-Byte` signed integer. Range: -128 to 127.
   - `short`: `16-bit or 2-Byte` signed integer. Range: -32,768 to 32,767.
   - `int`: `32-bit or 4-Byte` signed integer. Range: -2^31 to 2^31 - 1.
   - `long`: `64-bit or 8-Byte` signed integer. Range: -2^63 to 2^63 - 1.

   ```java
   byte myByte = 127;
   short myShort = 32767;
   int myInt = 2147483647;
   long myLong = 9223372036854775807L; // Note the 'L' suffix to denote it as a long literal
   int minValue = Integer.MIN_VALUE; // -2147483648
   int maxValue = Integer.MAX_VALUE; // 2147483648
   ```

2. **Floating-Point Numbers**:
   - `float`: `32-bit or 4-Byte` floating-point number. Range: approximately ±3.40282347E+38F.
   - `double`: `64-bit or 8-Byte` floating-point number. Range: approximately ±1.79769313486231570E+308.

   ```java
   float myFloat = 3.14f; // Note the 'f' suffix to denote it as a float literal
   double myDouble = 3.14159;
   ```

3. **Characters**:
   - `char`: `16-bit or 2-Byte` Unicode character. Range: '\u0000' to '\uffff'.

   ```java
   char myChar = 'A';
   ```

4. **Boolean**:
   - `boolean`: Represents true or false values. only takes `1-bit`

   ```java
   boolean myBoolean = true;
   ```

These primitive data types are directly supported by the Java programming language and are more efficient in terms of memory usage and performance compared to their object counterparts (e.g., `Integer`, `Double`, `Character`, etc.). They are used extensively in Java programs for representing and manipulating data efficiently.


## Classes In JAVA

In Java, classes are fundamental building blocks used for defining objects and their behavior in object-oriented programming (OOP). They serve as blueprints or templates for creating objects, which are instances of a class. Here's an overview of classes in Java:

1. **Definition**: A class in Java is defined using the `class` keyword followed by the class name. It typically contains fields (variables) and methods (functions) that define the behavior and properties of objects created from the class.

   ```java
   public class MyClass {
       // Fields (variables)
       private int myField;

       // Constructor
       public MyClass(int value) {
           myField = value;
       }

       // Methods
       public void myMethod() {
           // Method body
       }
   }
   ```

2. **Objects**: Objects are instances of classes. They are created using the `new` keyword followed by the class constructor. Each object has its own set of fields and can invoke methods defined in its class.

   ```java
   MyClass obj1 = new MyClass(10);
   MyClass obj2 = new MyClass(20);
   ```

3. **Fields (Variables)**: Fields are variables declared within a class. They represent the state of objects created from the class and define their properties. Fields can have different access modifiers (e.g., `public`, `private`, `protected`) to control their visibility and accessibility.

4. **Constructors**: Constructors are special methods used for initializing objects when they are created. They have the same name as the class and may have parameters to initialize object properties.

5. **Methods (Functions)**: Methods are functions defined within a class that define the behavior of objects created from the class. They can perform various operations and can access and modify the object's state through its fields.

6. **Inheritance**: Java supports inheritance, allowing classes to inherit fields and methods from other classes. This promotes code reuse and allows for hierarchical classification of classes.

7. **Encapsulation**: Encapsulation is the practice of bundling data (fields) and methods that operate on the data within a single unit (class). Access to the data is controlled through methods, promoting data security and integrity.

8. **Abstraction**: Abstraction is the process of hiding implementation details and exposing only the necessary features of an object. Classes and methods can be abstract, allowing for the creation of generic and reusable components.

9. **Polymorphism**: Polymorphism allows objects of different classes to be treated as objects of a common superclass. This enables methods to behave differently based on the actual object being operated upon, enhancing flexibility and extensibility.

Classes are essential for organizing and structuring Java programs in an object-oriented manner, promoting modularity, reusability, and maintainability of code.

## Wrapper Classes In JAVA
In Java, wrapper classes are a set of classes that provide an object-oriented way to represent primitive data types as objects. These classes wrap the primitive data types and provide methods to manipulate and work with them in an object-oriented context. The primary purpose of wrapper classes is to provide a way to treat primitive types as objects, allowing them to be used in scenarios where objects are required, such as collections, generics, and methods that require objects as parameters.

Java provides wrapper classes for each of its primitive data types:

1. `Byte`: Wraps a byte primitive type.
2. `Short`: Wraps a short primitive type.
3. `Integer`: Wraps an int primitive type.
4. `Long`: Wraps a long primitive type suffix `l or L`.
5. `Float`: Wraps a float primitive type suffex - `f or F`.
6. `Double`: Wraps a double primitive type.
7. `Character`: Wraps a char primitive type.
8. `Boolean`: Wraps a boolean primitive type.


**NOTE -** Always use `L` and `f` for long and float variables.

For example, if you want to use an `int` value as an object, you can use the `Integer` wrapper class:

```java
System.out.println(Long.SIZE); // A long has a width of 64
int primitiveInt = 10;
Integer wrappedInt = Integer.valueOf(primitiveInt); // Wrapping int value as an Integer object
```

Similarly, you can extract the primitive value from a wrapper object:

```java
Integer wrappedInt = Integer.valueOf(20);
int primitiveInt = wrappedInt.intValue(); // Extracting the int value from the Integer object
```

Wrapper classes also provide useful methods for converting between primitive types, parsing strings into primitive values, and performing arithmetic operations. Additionally, they are used extensively in Java's collections framework, as collections can only store objects, not primitive types.

Wrapper classes are also commonly used in scenarios where nullable values are required, as they can represent null values using the `null` keyword. However, wrapper classes incur a small overhead compared to primitive types due to the additional memory required to store the object overhead.

## Overflow And Underflow In JAVA
In Java, overflow and underflow refer to situations where the value of a variable exceeds its maximum or minimum limit, respectively, based on the data type of the variable. This can happen when performing arithmetic operations such as addition, subtraction, multiplication, or division, especially with primitive data types. Let's explore overflow and underflow with examples:

1. **Overflow**:

   Overflow occurs when a value exceeds the maximum limit that can be represented by its data type. For example, if you try to add two large integers that result in a value greater than the maximum value that can be represented by an `int`, overflow occurs.

   ```java
   int maxInt = Integer.MAX_VALUE; // Maximum value of int
   int overflow = maxInt + 1; // Overflow occurs here
   System.out.println(overflow); // Output: -2147483648 (Integer.MIN_VALUE)
   ```

   In this example, `maxInt` represents the maximum value that can be stored in an `int`. When you add 1 to it, the result exceeds the maximum limit, causing overflow. As a result, the value wraps around to the minimum value of `int` (Integer.MIN_VALUE).

2. **Underflow**:

   Underflow occurs when a value goes below the minimum limit that can be represented by its data type. For example, if you subtract a large value from a smaller one that results in a value less than the minimum value that can be represented by an `int`, underflow occurs.

   ```java
   int minInt = Integer.MIN_VALUE; // Minimum value of int
   int underflow = minInt - 1; // Underflow occurs here
   System.out.println(underflow); // Output: 2147483647 (Integer.MAX_VALUE)
   ```

   In this example, `minInt` represents the minimum value that can be stored in an `int`. When you subtract 1 from it, the result goes below the minimum limit, causing underflow. As a result, the value wraps around to the maximum value of `int` (Integer.MAX_VALUE).

Overflow and underflow can lead to unexpected behavior and errors in Java programs, so it's essential to handle them appropriately. In some cases, you may need to use larger data types or implement error-checking mechanisms to prevent or detect overflow and underflow situations.

**Note -** overflow and underflow works only for the expressions only.
**Note -** you will get an error if you directly assign a big integer to a variable 

**Note -** in java we can not use in between an integer but can use `_` as it will act as readable syntax.
```java
int num = 1,23,4; // wrong way
int num = 1_24_30_766; // acceptable
```


## Casting In JAVA
In Java, casting refers to the process of converting a value from one data type to another. There are two types of casting in Java: implicit casting (also known as widening conversion) and explicit casting (also known as narrowing conversion). Let's explore both types with examples:

1. **Implicit Casting (Widening Conversion)**:

   Implicit casting occurs when converting a value from a smaller data type to a larger data type. Java automatically performs implicit casting without any explicit instructions from the programmer because it does not result in any loss of data.

   ```java
   int myInt = 10;
   double myDouble = myInt; // Implicit casting from int to double
   System.out.println(myDouble); // Output: 10.0
   System.out.println("Hello Mayank " + 23) // "ello Mayank 23"
   System.out.println('A' + 'B'); // 131 -> 65 + 66
   ```

   In this example, the value of `myInt` (which is an `int`) is implicitly cast to a `double` when assigning it to `myDouble`. Since `double` can represent a wider range of values than `int`, no data is lost in this conversion.

2. **Explicit Casting (Narrowing Conversion)**:

   Explicit casting occurs when converting a value from a larger data type to a smaller data type. This type of casting requires explicit instructions from the programmer because it may result in loss of data.

   ```java
   double myDouble = 10.5;
   int myInt = (int) myDouble; // Explicit casting from double to int
   System.out.println(myInt); // Output: 10
   ```

   In this example, the value of `myDouble` (which is a `double`) is explicitly cast to an `int` using `(int)` before the variable name. Since `int` can represent a narrower range of values than `double`, the fractional part of `myDouble` is truncated (not rounded) when casting it to `int`.

It's important to note that when performing explicit casting, there is a risk of losing precision or encountering overflow or underflow if the value being casted is outside the range of the target data type. Therefore, you should use explicit casting with caution and ensure that it does not result in unexpected behavior or loss of data.

# Challange01

## Float And Double In JAVA
In Java, `float` and `double` are both primitive data types used to represent floating-point numbers (numbers with decimal points). Here's a brief explanation of each along with important points and examples:

1. **float**:
   - The `float` data type is a single-precision `32-bit` or `4-Byte` floating-point number in Java.
   - It can represent values with a `precision of approximately 7 decimal digits`.
   - In Java, float literals are suffixed with `f` or `F` to indicate that they are of type float.
   - Example:

     ```java
     float myFloat = 3.14f;
     ```

2. **double**:
   - The `double` data type is a double-precision `64-bit` or `8-Byte` floating-point number in Java.
   - It can represent values with a precision of approximately `15 decimal digits`.
   - `In Java, double literals are the default` for floating-point values and do not require a suffix.
   - Example:

     ```java
     double myDouble = 3.14159;
     ```

**Important Points**:

1. **Precision**: `double` has higher precision than `float`, so it is generally preferred for most applications requiring floating-point arithmetic.

2. **Default**: If you need to represent decimal values, `double` is the preferred choice unless you have memory constraints or specific performance requirements.

3. **Suffix**: When assigning float literals, it's important to use the `f` or `F` suffix to indicate that the value is of type float. Otherwise, it will be treated as a `double` by default.

4. **Memory Usage**: `float` consumes less memory (4 bytes) compared to `double` (8 bytes), but it sacrifices precision for this memory efficiency.

5. **Type Promotion**: In expressions involving both `float` and `double`, `float` values are automatically promoted to `double` before any arithmetic operation is performed.

6. **Range**: `double` has a wider range of values compared to `float`, allowing it to represent larger and smaller numbers without loss of precision.

7. **Performance**: In modern hardware, the performance difference between `float` and `double` arithmetic is negligible, so the choice between them is often based on precision requirements rather than performance considerations.

When deciding between `float` and `double`, consider the precision required for your application and any memory constraints you may have. In most cases, `double` is suitable for general-purpose floating-point arithmetic due to its higher precision and widespread use in Java libraries and APIs.

**Example which shows which is more precised double or float**
```java
float f = 5 / 3f; // 1.6666666
double d = 5 / 3d; // 1.6666666666666667
double g = 5 / 3f; // 1.6666666269302368 taking garbage value after 7 decimal points in java
```

Read About `EPS` and these blogs 

* https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

* https://codeforces.com/blog/entry/48465

* https://cp-algorithms.com/algebra/fft.html#toc-tgt-7


Neither Double and float are good for precision as such. This is not java specific problem but how the floating point numbers are stored in memory their is a class `BigDecimal` which overcomes it.


#### Range Of Float And Double In JAVA
In Java, the `float` and `double` data types are used to represent floating-point numbers. They can represent a wide range of values, both positive and negative, but with different precision levels. Here are the ranges of `float` and `double` in both scientific (exponential) notation and normal notation:

1. **float**:

   - **Scientific Notation**: ±(1.4 x 10^-45) to ±(3.4 x 10^38)
   - **Normal Notation**: ±1.4 x 10^-45 to ±3.4 x 10^38
   - **Decimal Notation**: -3.4028235 × 10^38 to 3.4028235 × 10^38

2. **double**:

   - **Scientific Notation**: ±(4.9 x 10^-324) to ±(1.7 x 10^308)
   - **Normal Notation**: ±4.9 x 10^-324 to ±1.7 x 10^308
   - **Decimal Notation**: -1.7976931348623157 × 10^308 to 1.7976931348623157 × 10^308

These ranges represent the minimum and maximum values that can be represented by each data type. It's important to note that the precision of `float` is lower compared to `double`, so it's generally less accurate when representing very large or very small values. Therefore, `double` is typically preferred for most applications requiring floating-point arithmetic due to its higher precision.

Here's how you can represent these ranges in Java code:

```java
// float range in scientific notation
float minFloatScientific = 1.4e-45f;
float maxFloatScientific = 3.4e38f;

// float range in normal notation
float minFloatNormal = 1.4e-45f;
float maxFloatNormal = 3.4e38f;

// float range in decimal format
float minFloat = -3.4028235e38f;
float maxFloat = 3.4028235e38f;

// double range in scientific notation
double minDoubleScientific = 4.9e-324;
double maxDoubleScientific = 1.7e308;

// double range in normal notation
double minDoubleNormal = 4.9e-324;
double maxDoubleNormal = 1.7e308;

// double range in decimal format
double minDouble = -1.7976931348623157e308;
double maxDouble = 1.7976931348623157e308;
```

These values are based on the IEEE 754 floating-point standard, which Java follows for representing floating-point numbers.

**Note ->** in an expression whetever big datatype is there it will evaluate according to it and the order is like this -

`int < long < float < double`

for example -
```java
int a = 5 / 2; //  2 not 2.5
float b = 5f / 2; // 2.5
long c = 1000L / 2; // 5000L
double d = 10000L / 2f; // 5000.00000
float f = 5.00 / 2f; // give error bcoz here double is there so double value will be evaluated and assigned to a float varaible
```

## Char And Boolean Data Types In JAVA

Sure, here's a brief introduction to the `char` and `boolean` data types in Java, along with examples:

1. **char**:
   - The `char` data type in Java is used to represent single characters.
   - It is a `16-bit` or `2byte` unsigned integer type.(IN CPP it is `8bits` or `1-byte` only).
   - it ios bcoz [UNICODE](https://home.unicode.org/) Is the standard for the encoding in java which has more characters rather than the ASCII Value.
   - Characters in Java are represented using Unicode encoding, which allows for a wide range of characters from various languages and symbol sets.
   - Char literals are enclosed in single quotes (`'`) and can represent a single character, escape sequences, or Unicode characters.
   - Example:

     ```java
     char myChar = 'A';
     char newLineChar = '\n'; // Represents a newline character
     char unicodeChar = '\u00A9'; // Represents the copyright symbol (©)
     ```


* check it out also - https://symbl.cc/en/


2. **boolean**:
   - The `boolean` data type in Java represents a boolean value, which can be either `true` or `false`.
   - takes only `1-bit` only.
   - It is commonly used for boolean expressions, conditional statements, and control flow in Java programs.
   - The `boolean` data type only has two possible values: `true` and `false`.
   - it's a good pratice to always use `is` as the prefix with boolean variables in JAVA.
   - Example:

     ```java
     boolean isJavaFun = true;
     boolean isJavaHard = false;
     ```

   - Boolean values are often the result of comparisons or logical operations.

Both `char` and `boolean` are primitive data types in Java, meaning they hold a single value directly in memory. They are frequently used in various programming tasks, including text processing, user input validation, and control flow logic.


## String Literals And String DataType In JAVA
A string literal in Java is a sequence of characters enclosed within double quotes `""`. String literals are used to represent textual data in Java programs. Here's a discussion on string literals, their uses, and important points about them, along with the String data type:

1. **String Literal**:
   - A string literal is a constant value of the String data type.
   - It represents a fixed sequence of characters enclosed within double quotes.
   - Examples of string literals: `"Hello"`, `"Java"`, `"12345"`, etc.

2. **Uses of String Literals**:
   - String literals are commonly used to represent textual data such as names, messages, file paths, etc., in Java programs.
   - They are used in variable assignments, method parameters, and expressions where text data is required.
   - String literals are often used in concatenation operations to build longer strings.
   - for Example 
   ```java
   System.out.println("Hey My Age is " + age);
   ```

3. **Important Points about String Literals**:
   - String literals are `immutable`, meaning their values cannot be changed after they are created.
   - Java maintains a `string literal pool`, also known as the `string constant pool`, to store `unique instances` of string literals. This helps `conserve memory` by reusing identical string literals.
   - `Strings created using string literals` are interned by default, meaning they are `automatically added to the string pool`.
   - String literals can contain escape sequences to represent special characters such as newline (`\n`), tab (`\t`), double quote (`\"`), or `\u0024 or $` etc.
   - Concatenating string literals using the `+` operator creates a new string object.

4. **String Data Type**:
   - The String data type in Java is a `class` that represents a sequence of characters.
   - Strings are widely used in Java programming for text processing, manipulation, and storage.
   - Strings in Java are `objects`, `not primitive data types`. However, they are used so frequently that Java provides special syntax and features to work with them efficiently.
   - String objects can be created using either string literals or the `new` keyword.
   - Example:

     ```java
     String str1 = "Hello"; // String created using a string literal
     String str2 = new String("Java"); // String created using the new keyword
     ```

   - The String class provides a rich set of methods for performing various operations such as `concatenation`, `substring` extraction, `searching`, `comparison`, and more.

Overall, string literals are a convenient and efficient way to represent textual data in Java programs. They play a crucial role in many Java applications and are fundamental to text processing and manipulation. Understanding their characteristics and usage is essential for writing efficient and robust Java code.

Everytime we assign new string or concate something in a existing string than overall internally a new string is created which is assigned to this string variable and the older one get discarded auatomatically from the memory.


This is why `String` Class is inefficient there is `String Builder` Class which is more efficient than String Class.

## String Builder In JAVA

`StringBuilder` is more efficient than the normal `String` class in Java for certain operations, particularly when `concatenating multiple strings` or performing repeated modifications to a string. This efficiency arises due to the mutable nature of `StringBuilder` compared to the immutable nature of `String`. Here's why `StringBuilder` is more efficient in certain scenarios:

we can not assign `String literal` to a `string builder`.

1. **Mutability**:
   - `StringBuilder` is mutable, meaning its contents can be modified without creating a new object. In contrast, `String` objects are immutable, so every modification operation (such as concatenation) creates a new string object.
   - When concatenating multiple strings with `StringBuilder`, the `internal buffer` of the `StringBuilder` object is `resized dynamically to accommodate the new data`, avoiding the overhead of creating multiple intermediate string objects.

2. **Performance**:
   - `StringBuilder` offers better performance for operations that involve a large number of string manipulations, such as repeated concatenations within loops.
   - `StringBuilder` avoids the memory overhead and performance penalties associated with creating and discarding multiple `String` objects.

3. **Memory Efficiency**:
   - `StringBuilder` uses a `resizable array (buffer) to store character data`, which minimizes memory usage and reduces the need for memory reallocation.
   - `StringBuilder` allows you to specify an initial capacity for the buffer, which can help optimize memory usage for specific scenarios.

4. **Concurrency**:
   - `StringBuilder` is not `thread-safe`, which means it is more efficient in single-threaded environments where thread safety is not a concern.
   - If `thread safety` is required, the `StringBuffer` class can be used, which is similar to `StringBuilder` but provides thread-safe operations through synchronization.

However, it's important to note that while `StringBuilder` is more efficient for string manipulation operations, `String` objects have advantages in terms of immutability, thread safety, and caching (e.g., string literals). Therefore, the choice between `StringBuilder` and `String` depends on the specific requirements and characteristics of the task at hand. In general, prefer `StringBuilder` for dynamic string manipulations and `String` for cases where immutability and thread safety are important.


Let's illustrate the efficiency of `StringBuilder` over `String` with an example involving concatenation of multiple strings inside a loop:

```java
public class StringBuilderVsString {
    public static void main(String[] args) {
        // Concatenating strings using StringBuilder
        long startTimeStringBuilder = System.nanoTime();
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            stringBuilder.append("Hello");
        }
        String resultStringBuilder = stringBuilder.toString();
        long endTimeStringBuilder = System.nanoTime();
        long durationStringBuilder = endTimeStringBuilder - startTimeStringBuilder;

        // Concatenating strings using String
        long startTimeString = System.nanoTime();
        String resultString = "";
        for (int i = 0; i < 10000; i++) {
            resultString += "Hello";
        }
        long endTimeString = System.nanoTime();
        long durationString = endTimeString - startTimeString;

        // Displaying durations
        System.out.println("StringBuilder duration: " + durationStringBuilder + " nanoseconds");
        System.out.println("String duration: " + durationString + " nanoseconds");
    }
}
```

In this example, we concatenate the string "Hello" 10,000 times using both `StringBuilder` and `String`. We then measure the time taken by each approach.

When you run this code, you'll likely find that `StringBuilder` is significantly faster than using `String` concatenation. This is because:

1. **StringBuilder is Mutable**: `StringBuilder` allows you to modify its contents without creating a new object for each concatenation operation. In contrast, when using `String` concatenation (`+=`), a new `String` object is created for each concatenation, resulting in inefficient memory usage and performance overhead.

2. **Efficient Memory Allocation**: `StringBuilder` uses an `internal buffer` to store the concatenated strings, which can dynamically resize as needed. This avoids the overhead of constantly allocating and deallocating memory for new `String` objects, resulting in better memory usage and performance.

3. **Reduced Garbage Collection Overhead**: Since `StringBuilder` modifies its `internal buffer` directly, it generates less garbage compared to `String` concatenation, where multiple intermediate `String` objects are created and discarded during the concatenation process. This reduces the workload of the garbage collector, leading to better overall performance.

By using `StringBuilder` instead of `String` concatenation for tasks involving dynamic string manipulation, you can achieve better performance and more efficient memory usage, especially when dealing with large amounts of data or repetitive string operations.


## Operators In JAVA

### Arthimatic Assignment Operators:-  
    +=, -=, /=, *= , %= [Less Complexxity Than Vice Versa]
 
### Unary Operators:- 
   `+,-, ++, --`
    ++a -> increments the value and than returns it [pre-increment operator]
    a++ -> returns the value and than increments the value [post-increment operator]

### Conditional Opertaors
    ==, !=
### Relational Operators
    >, <, <=, >=
### Logical Operators
    &&, ||, !


### Arithimatic Operators In C++   
JAVA follows `BODMAS`(Bracket, Orders(x<sup>2</sup>, sqrt(x)), Division, Multiplication, Addition, and Subtraction) Rule of Mathematics.

`+` -> Addition Operator [add two values]

`-` -> Subatraction Operator [Subtract two values]

`*` -> Multiply Operator [Multiplies two values]

`/` -> Devide Operator [gives quotient two values] 

`%` -> Modulo Operator [remainder two values] , [Not Works For Float Numbers]

`NOTE -> Never use 0 as dividend it will create unusual errors `


#### **Note ->** 
`A arthimatic operation Always gives values according to the higher order datatype of any eliment which is used `in Operation Like ->

```
10/5 -> 2 which is a integer and because higher datatype which is used is Integer
       
10/4 -> 2[Not 2.5] which is a integer and because higher datatype which is used is Integer

10/4.0 -> 2.5[Not 2] which is a float and because higher datatype which is used is float
       
(10/4)*1.0 -> 2.00[Not 2.5] because ***() will truncate***[Truncate and round off are two different things] the decimal value and convert it to a integer.
```

`(N % k + k)`  this expression can be used to handle negative remainder ... 
Related Problems -> 
[Problem1](https://leetcode.com/problems/subarray-sums-divisible-by-k/description/)

`If NUmber is become to big than we can use previous remainder to get remainder fot current number`
Releted Problems ->

[Problem1](https://leetcode.com/problems/find-the-divisibility-array-of-a-string/)
[Problem2](https://www.codechef.com/problems/EPANLNK)


**NOTE -** 
`x -= y` is not always equal `x = x - y`
internally when you have different data types than it works differently like -
`x -= y` is actually `(data type of x)(x - y);` 
an `implicit casting` is occur when using this operator, but no error occurs, but unexpected results may occur.

```java
int x = 10;
x -= 5.5; // 4
and 
x = x - 5.5; // throw an error
```