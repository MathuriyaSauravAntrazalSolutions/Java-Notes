# I/O Stream
In Java, I/O (Input/Output) streams are used to handle reading from and writing to different sources and destinations, such as files, network connections, system input/output, etc. Streams represent a sequence of data flowing between a Java program and an I/O device.

Java provides two main types of streams: input streams and output streams.

## **Input Streams**:
   Input streams are used for reading data from a source into a Java program. They provide methods for reading primitive data types `(bytes, characters, etc.)` from various sources. Examples of input streams include `FileInputStream`,  `BufferedInputStream`, `ObjectInputStream`, etc.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   ```

An Input Stream is used for reading data into a Java program from a source. It's an abstract class (`java.io.InputStream`) representing a stream of bytes. Input streams are typically used to read data from files, network connections, or other input sources.

Some common subclasses of InputStream include:
- `FileInputStream`: Reads bytes from a file.
- `ByteArrayInputStream`: Reads bytes from a byte array.
- `ObjectInputStream`: Reads objects from an input stream.
- `BufferedInputStream`: Adds buffering capabilities to an input stream for improved performance.

## **Output Streams**:
   Output streams are used for writing data from a Java program to a destination. They provide methods for writing primitive data types (bytes, characters, etc.) to various destinations. Examples of output streams include `FileOutputStream`, `BufferedOutputStream`, `ObjectOutputStream`, etc.

   ```java
   OutputStream outputStream = new FileOutputStream("file.txt");
   ```

An Output Stream is used for writing data from a Java program to a destination. It's also an abstract class (`java.io.OutputStream`) representing a stream of bytes. Output streams are used to write data to files, network connections, or other output destinations.

Some common subclasses of OutputStream include:
- `FileOutputStream`: Writes bytes to a file.
- `ByteArrayOutputStream`: Writes bytes to a byte array.
- `ObjectOutputStream`: Writes objects to an output stream.
- `BufferedOutputStream`: Adds buffering capabilities to an output stream for improved performance.

### Example:
Here's a simple example demonstrating the usage of InputStream and OutputStream to copy the contents of one file to another:

```java
import java.io.*;

public class FileCopy {
    public static void main(String[] args) {
        try (InputStream inputStream = new FileInputStream("input.txt");
             OutputStream outputStream = new FileOutputStream("output.txt")) {

            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }

            System.out.println("File copied successfully!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

In this example:
- We're using FileInputStream to read bytes from the file "input.txt".
- We're using FileOutputStream to write bytes to the file "output.txt".
- We're reading data from the input stream into a buffer and then writing that data to the output stream until the end of the file is reached.
- We're using a try-with-resources block to ensure proper closing of the streams, even if an exception occurs.


Java I/O streams follow a hierarchical structure, with higher-level streams built on top of lower-level streams. For example, `BufferedInputStream` is a wrapper around `FileInputStream` that provides buffering capabilities to improve I/O performance.

Here's a simple example of reading from an input stream and writing to an output stream:

```java
try (InputStream inputStream = new FileInputStream("input.txt");
     OutputStream outputStream = new FileOutputStream("output.txt")) {
    int data;
    while ((data = inputStream.read()) != -1) {
        outputStream.write(data);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

In this example:
- We're reading bytes from an input file (`input.txt`) using a `FileInputStream`.
- We're writing those bytes to an output file (`output.txt`) using a `FileOutputStream`.
- We're using a `try-with-resources` block to ensure that the streams are closed properly after their use. This is a convenient way to handle resources in Java and ensures that the streams are closed even if an exception occurs during processing.



## Input Stream Methods
Below are the methods of the `InputStream` class along with examples:

1. **int read()**:
   Reads the next byte of data from the input stream. Returns the byte read as an integer in the range 0 to 255 (0x00-0xFF), or -1 if the end of the stream is reached.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   int data = inputStream.read();
   while (data != -1) {
       System.out.print((char) data);
       data = inputStream.read();
   }
   inputStream.close();
   ```

2. **int read(byte[] b)**:
   Reads some number of bytes from the input stream and stores them into the byte array `b`. Returns the total number of bytes read into the buffer, or -1 if there is no more data because the end of the stream has been reached.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   byte[] buffer = new byte[1024];
   int bytesRead = inputStream.read(buffer);
   while (bytesRead != -1) {
       // Process the data in buffer
       bytesRead = inputStream.read(buffer);
   }
   inputStream.close();
   ```

3. **int read(byte[] b, int off, int len)**:
   Reads up to `len` bytes of data from the input stream into an array of bytes. The bytes read are stored starting at the given offset `off` in the array `b`. Returns the total number of bytes read into the buffer, or -1 if there is no more data because the end of the stream has been reached.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   byte[] buffer = new byte[1024];
   int bytesRead = inputStream.read(buffer, 0, 1024);
   while (bytesRead != -1) {
       // Process the data in buffer
       bytesRead = inputStream.read(buffer, 0, 1024);
   }
   inputStream.close();
   ```

4. **long skip(long n)**:
   Skips over and discards `n` bytes of data from the input stream. Returns the actual number of bytes skipped.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   long skippedBytes = inputStream.skip(100); // Skip 100 bytes
   ```

5. **int available()**:
   Returns an estimate of the number of bytes that can be read (or skipped over) from the input stream without blocking. This method can be overridden by subclasses to provide a more accurate estimate.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   int availableBytes = inputStream.available();
   ```

6. **void close()**:
   Closes the input stream and releases any system resources associated with it. Once the stream has been closed, further read attempts will throw an IOException.

   ```java
   InputStream inputStream = new FileInputStream("file.txt");
   inputStream.close();
   ```

These are the core methods provided by the `InputStream` class along with examples of how to use them. Make sure to handle exceptions appropriately when working with input streams, typically by using try-with-resources or by catching IOExceptions.


## Mark And Reset And Mark Supported
The `mark()` and `reset()` methods in Java are used to mark a point in an input stream and then return to that point later. These methods are provided by the `InputStream` class, but not all input streams support marking. You can check if an input stream supports marking using the `markSupported()` method.

Here's a brief explanation of each method:

1. **mark(int readLimit)**:
   This method marks the current position in the input stream. The `readLimit` parameter specifies the maximum number of bytes that can be read from the input stream before the mark becomes invalid. If more than `readLimit` bytes are read before calling the `reset()` method, the mark may be invalidated.

2. **reset()**:
   This method resets the input stream to the last marked position. It allows you to re-read the data that was previously read from the input stream after calling the `mark()` method. If the input stream has not been marked or if the mark is no longer valid (i.e., more bytes have been read than the specified `readLimit`), calling `reset()` will throw an `IOException`.

3. **markSupported()**:
   This method returns a boolean value indicating whether the input stream supports the `mark()` and `reset()` operations. If `markSupported()` returns `true`, you can use `mark()` and `reset()` on the input stream. If it returns `false`, attempting to use `mark()` and `reset()` will result in an `IOException`.

**Note:** Not All Stream Supports Marking Buffered Stream Supports Marking.

Here's an example demonstrating the usage of `mark()`, `reset()`, and `markSupported()`:

```java
InputStream inputStream = new FileInputStream("file.txt");

if (inputStream.markSupported()) {
    // Mark the current position in the input stream
    inputStream.mark(100); // Mark with a read limit of 100 bytes

    // Read and process some data from the input stream
    byte[] buffer = new byte[1024];
    int bytesRead = inputStream.read(buffer, 0, 1024);

    // Reset the input stream to the last marked position
    inputStream.reset();
}
```

In this example:
- We first check if the input stream supports marking by calling `markSupported()`.
- If marking is supported, we mark the current position in the input stream using `mark()`.
- We then read some data from the input stream and process it.
- Finally, we reset the input stream to the last marked position using `reset()`.

## Output Stream Methods
Output streams in Java are used for writing data from a Java program to an external destination, such as a file, network connection, or other output device. The `OutputStream` class is an abstract class representing an output stream of bytes, and it serves as the superclass for all classes representing output streams. Here are some commonly used methods provided by the `OutputStream` class and its subclasses:

1. **void write(int b)**:
   Writes the specified byte to the output stream.

   ```java
   OutputStream outputStream = new FileOutputStream("file.txt");
   outputStream.write(65); // Writes the byte representing 'A' to the file
   ```

2. **void write(byte[] b)**:
   Writes `b.length` bytes from the specified byte array to the output stream.

   ```java
   OutputStream outputStream = new FileOutputStream("file.txt");
   byte[] data = {65, 66, 67, 68}; // 'A', 'B', 'C', 'D'
   outputStream.write(data); // Writes the bytes 'A', 'B', 'C', 'D' to the file
   ```

3. **void write(byte[] b, int off, int len)**:
   Writes `len` bytes from the specified byte array starting at offset `off` to the output stream.

   ```java
   OutputStream outputStream = new FileOutputStream("file.txt");
   byte[] data = {65, 66, 67, 68}; // 'A', 'B', 'C', 'D'
   outputStream.write(data, 1, 2); // Writes bytes 'B', 'C' to the file
   ```

4. **void flush()**:
   Flushes the output stream, forcing `any buffered output bytes` to be written out to the stream.

   ```java
   OutputStream outputStream = new FileOutputStream("file.txt");
   outputStream.write(65); // Writes the byte representing 'A' to the file
   outputStream.flush(); // Forces the byte to be written to the file immediately
   ```

5. **void close()**:
   Closes the output stream and releases any system resources associated with it. Once the stream has been closed, further write attempts will throw an `IOException`.

   ```java
   OutputStream outputStream = new FileOutputStream("file.txt");
   outputStream.write(65); // Writes the byte representing 'A' to the file
   outputStream.close(); // Closes the output stream
   ```

These are some of the core methods provided by the `OutputStream` class. Subclasses such as `FileOutputStream`, `ByteArrayOutputStream`, and others may provide additional methods specific to their implementations. Always consult the documentation for the specific subclass you are using for a complete list of available methods and their descriptions.

**Note:** Not all Streams Supports Flush but Buffered Stream Supports Flush.


# I/O Stream Classes
The hierarchy of input and output stream classes in Java can be represented as follows, along with the relevant methods inherited from the `Object` class:

```
Object
│
├── InputStream
│   ├── ByteArrayInputStream
│   ├── FileInputStream
│   ├── FilterInputStream
│   │   ├── BufferedInputStream
│   │   ├── DataInputStream
│   │   ├── PushbackInputStream
│   │   └── ...
│   ├── ObjectInputStream
│   ├── PipedInputStream
│   └── ...
│
└── OutputStream
    ├── ByteArrayOutputStream
    ├── FileOutputStream
    ├── FilterOutputStream
    │   ├── BufferedOutputStream
    │   ├── DataOutputStream
    │   └── ...
    ├── ObjectOutputStream
    ├── PipedOutputStream
    └── ...
```

The `Object` class is the root of the Java class hierarchy. All classes in Java are direct or indirect subclasses of `Object`.

The `InputStream` and `OutputStream` abstract classes represent input and output streams, respectively. They serve as the base classes for various types of input and output streams in Java.

Subclasses of `InputStream` include:
- `ByteArrayInputStream`: Reads bytes from a byte array.
- `FileInputStream`: Reads bytes from a file.
- `FilterInputStream`: Provides a base class for filtering input streams.
- `ObjectInputStream`: Reads objects from an input stream.
- `BufferedInputStream`: Adds buffering capabilities to an input stream.
- `DataInputStream`: Reads primitive data types from an input stream.
- `PushbackInputStream`: Allows pushing back bytes into the input stream.

Subclasses of `OutputStream` include:
- `ByteArrayOutputStream`: Writes bytes to a byte array.
- `FileOutputStream`: Writes bytes to a file.
- `FilterOutputStream`: Provides a base class for filtering output streams.
- `ObjectOutputStream`: Writes objects to an output stream.
- `BufferedOutputStream`: Adds buffering capabilities to an output stream.
- `DataOutputStream`: Writes primitive data types to an output stream.
- `PipedOutputStream`: Connects to a piped input stream.

These classes provide methods for reading from and writing to different sources and destinations in Java. They form the foundation for input/output operations in Java programs.


## Reader And Writer Classes In JAVA
The hierarchy of reader and writer stream classes in Java, along with the relevant methods inherited from the `Object` class, can be represented as follows:

```
Object
│
├── Reader
│   ├── BufferedReader
│   ├── CharArrayReader
│   ├── FilterReader
│   │   ├── InputStreamReader
│   │   ├── LineNumberReader
│   │   └── ...
│   ├── PipedReader
│   └── ...
│
└── Writer
    ├── BufferedWriter
    ├── CharArrayWriter
    ├── FilterWriter
    │   ├── OutputStreamWriter
    │   └── ...
    ├── PipedWriter
    └── ...
```

The `Object` class is the root of the Java class hierarchy. All classes in Java are direct or indirect subclasses of `Object`.

The `Reader` and `Writer` abstract classes represent character stream input and output, respectively. They serve as the base classes for various types of character streams in Java.

Subclasses of `Reader` include:
- `BufferedReader`: Adds buffering capabilities to a character input stream.
- `CharArrayReader`: Reads characters from a character array.
- `FilterReader`: Provides a base class for filtering character input streams.
- `InputStreamReader`: Translates bytes from an input stream into characters.
- `LineNumberReader`: Keeps track of line numbers in character input streams.
- `PipedReader`: Connects to a piped writer.

Subclasses of `Writer` include:
- `BufferedWriter`: Adds buffering capabilities to a character output stream.
- `CharArrayWriter`: Writes characters to a character array.
- `FilterWriter`: Provides a base class for filtering character output streams.
- `OutputStreamWriter`: Translates characters into bytes to be written to an output stream.
- `PipedWriter`: Connects to a piped reader.

These classes provide methods for reading characters from and writing characters to different sources and destinations in Java. They form the foundation for character-based input/output operations in Java programs.

Example Of OutputStream:
```java
    public static void main(String[] args) {
        // OutputStream is parent reffrence
        try (OutputStream outputStream = new FileOutputStream("./Challanges/file.txt")) {
            String str = "Learn Java Programming";
            byte[] data = str.getBytes(); 
            outputStream.write(data);
            outputStream.write(data, 6, str.length()-6);
        } catch(FileNotFoundException e){
            System.out.println(e.getMessage());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

ORRRRR

    public static void main(String[] args) throws IOException {
        // OutputStream is parent reffrence
        try (FileWriter outputStream = new FileWriter("./Challanges/file.txt")) {
            String str = "Learn Java Programming";
            outputStream.write(str);
            outputStream.write(str, 6, str.length()-6);
        }
    }
```

Example Of InputStream:
```java
    public static void main(String[] args) {
        try (FileInputStream inputStream = new FileInputStream("./Challanges/file.txt")) {
            byte[] data = new byte[inputStream.available()]; 
            inputStream.read(data);
            String str = new String(data);
            System.out.println(str);
        } catch(FileNotFoundException e){
            System.out.println(e.getMessage());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

ORRRRR

    public static void main(String[] args) throws IOException{
        try (FileInputStream inputStream = new FileInputStream("./Challanges/file.txt")) {
            int data;
            while((data = inputStream.read())!=-1){
                System.out.print((char)data);
            }
            System.out.println();
            System.out.println(data); // -1
        }
    }

ORRRRR

    public static void main(String[] args) throws IOException{
        try (FileReader inputStream = new FileReader("./Challanges/file.txt")) {
            int data;
            while((data = inputStream.read())!=-1){
                System.out.print((char)data);
            }
            System.out.println();
            System.out.println(data); // -1
        }
    }

ORRRRR

    public static void main(String[] args) throws IOException{
        try (Reader inputStream = new FileReader("./Challanges/file.txt")) {
            int data;
            while((data = inputStream.read())!=-1){
                System.out.print((char)data);
            }
            System.out.println();
            System.out.println(data); // -1
        }
    }

```

#### Challange 
Copy A file Content(All In UpperCase) in Other File in Lower case characters.
```java
    public static void main(String[] args) throws IOException {
        try(FileInputStream fis = new FileInputStream("./Challanges/input.txt")){
            byte[] data = new byte[fis.available()];
            fis.read(data);
            try (FileOutputStream fos = new FileOutputStream("./Challanges/output.txt")) {
                for(byte by: data){
                    if((char)by!=' ') fos.write(by+(97-65));
                    else fos.write(by);
                }
            }
        }
    }
```


## ByteArrayInput And Output Stream
### ByteArrayInputStream:
`ByteArrayInputStream` is a class in Java that implements an input stream that reads bytes from a byte array. It allows you to read data from a byte array as if it were an input stream. This can be useful in various scenarios, such as when you need to read data from a byte array but you have methods that expect an input stream.

Here's a basic example of how you might use `ByteArrayInputStream`:

```java
import java.io.ByteArrayInputStream;
import java.io.IOException;

public class ByteArrayInputStreamExample {
    public static void main(String[] args) {
        // Create a byte array
        byte[] byteArray = {65, 66, 67, 68, 69};

        // Create a ByteArrayInputStream with the byte array
        ByteArrayInputStream inputStream = new ByteArrayInputStream(byteArray);

        try {
            // Read bytes from the stream and print them
            int data;
            while ((data = inputStream.read()) != -1) {
                System.out.print((char) data + " ");
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // Close the stream
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

In this example:

1. We create a byte array `byteArray` containing ASCII values of characters 'A' through 'E'.
2. We create a `ByteArrayInputStream` named `inputStream` using the byte array.
3. We read bytes from the `inputStream` in a loop until there are no more bytes to read, converting each byte to a character and printing it.
4. We close the `inputStream` in a finally block to ensure it is properly closed, handling any potential `IOException` that might occur.

`ByteArrayInputStream` is useful for reading data from byte arrays in memory without the need for a physical file or network connection.

### ByteArrayOutputStream:
`ByteArrayOutputStream` is another class in Java that works in conjunction with `ByteArrayInputStream`. While `ByteArrayInputStream` allows you to read bytes from a byte array as an input stream, `ByteArrayOutputStream` allows you to write bytes to a byte array as an output stream.

Here's a basic example of how you might use `ByteArrayOutputStream`:

```java
import java.io.ByteArrayOutputStream;
import java.io.IOException;

public class ByteArrayOutputStreamExample {
    public static void main(String[] args) {
        // Create a new ByteArrayOutputStream
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        // Write some data to the stream
        String data = "Hello, world!";
        try {
            outputStream.write(data.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Get the byte array from the stream
        byte[] byteArray = outputStream.toByteArray();

        // Print the contents of the byte array
        System.out.println(new String(byteArray));

        // Close the stream (not necessary for ByteArrayOutputStream)
        try {
            outputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

In this example:

1. We create a `ByteArrayOutputStream` named `outputStream`.
2. We write the string "Hello, world!" to the stream using the `write` method.
3. We retrieve the byte array containing the data written to the stream using the `toByteArray` method.
4. We print the contents of the byte array as a string.
5. We close the stream, although this is not strictly necessary for a `ByteArrayOutputStream`.

`ByteArrayOutputStream` is commonly used when you need to generate data in memory and then process it later. It's particularly useful when you need to convert data to a byte array for further processing or transmission.

## CharArrayReader And Writer
### CharArrayReader:
`CharArrayReader` is a class in Java that allows you to create a character stream that reads from a character array. It is useful when you need to read character data from an in-memory buffer rather than from an external source like a file or network stream.

Here's a basic example of how you might use `CharArrayReader`:

```java
import java.io.CharArrayReader;
import java.io.IOException;

public class CharArrayReaderExample {
    public static void main(String[] args) {
        // Create a character array
        char[] charArray = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!'};

        // Create a CharArrayReader with the character array
        CharArrayReader reader = new CharArrayReader(charArray);

        try {
            // Read characters from the stream and print them
            int data;
            while ((data = reader.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // Close the stream
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

In this example:

1. We create a character array `charArray` containing the characters of the string "Hello, world!".
2. We create a `CharArrayReader` named `reader` using the character array.
3. We read characters from the `reader` in a loop until there are no more characters to read, printing each character.
4. We close the `reader` in a finally block to ensure it is properly closed, handling any potential `IOException` that might occur.

`CharArrayReader` is useful when you need to read character data from a character array without the need for external I/O operations. It's often used in scenarios where you have character data in memory and need to process it as a stream.

### CharArrayWriter:
`CharArrayWriter` is a class in Java that provides a character buffer for writing data. It allows you to write characters to an internal character array buffer, which can then be accessed as a string or converted to a character array.

Here's a basic example of how you might use `CharArrayWriter`:

```java
import java.io.CharArrayWriter;
import java.io.IOException;

public class CharArrayWriterExample {
    public static void main(String[] args) {
        // Create a CharArrayWriter
        CharArrayWriter writer = new CharArrayWriter();

        try {
            // Write some data to the writer
            writer.write("Hello, ");
            writer.write("world!");

            // Get the contents of the writer as a string
            String contents = writer.toString();

            // Print the contents
            System.out.println(contents);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // Close the writer (not strictly necessary for CharArrayWriter)
            try {
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

In this example:

1. We create a `CharArrayWriter` named `writer`.
2. We write the strings "Hello, " and "world!" to the writer using the `write` method.
3. We retrieve the contents of the writer as a string using the `toString` method.
4. We print the contents of the writer.
5. We close the writer, although this is not strictly necessary for a `CharArrayWriter`.

`CharArrayWriter` is useful when you need to build up character data in memory before processing it further. It provides a flexible and efficient way to accumulate character data without the overhead of I/O operations.


## BufferedInputStream And Output Stream
`BufferedInputStream` and `BufferedOutputStream` are classes in Java that provide buffering functionality for input and output streams, respectively. They improve I/O performance by reducing the number of times data is physically read from or written to the underlying stream.

Here's a brief explanation of each:

1. **BufferedInputStream**:
   - `BufferedInputStream` adds buffering capability to an input stream, such as `FileInputStream` or `ByteArrayInputStream`.
   - It reads data from the underlying input stream into an internal buffer and then delivers bytes from this buffer to the caller when reading is requested.
   - Reading data from the buffer is faster than reading directly from the input stream because fewer system calls are made to the underlying stream.
   - It provides a more efficient way to read data, especially when the underlying input stream involves costly operations, such as file or network I/O.

2. **BufferedOutputStream**:
   - `BufferedOutputStream` adds buffering capability to an output stream, such as `FileOutputStream` or `ByteArrayOutputStream`.
   - It accumulates output data into an internal buffer and periodically flushes this buffer to the underlying output stream.
   - Writing data to the buffer is faster than writing directly to the output stream because fewer system calls are made to the underlying stream.
   - It provides a more efficient way to write data, especially when the underlying output stream involves costly operations, such as file or network I/O.

Here's a basic example demonstrating the use of `BufferedInputStream` and `BufferedOutputStream` together:

```java
import java.io.*;

public class BufferedStreamsExample {
    public static void main(String[] args) {
        try (
            // Create a BufferedInputStream with FileInputStream
            BufferedInputStream in = new BufferedInputStream(new FileInputStream("input.txt"));
            // Create a BufferedOutputStream with FileOutputStream
            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream("output.txt"))
        ) {
            int byteRead;
            // Read bytes from input stream and write them to output stream
            while ((byteRead = in.read()) != -1) {
                out.write(byteRead);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

In this example:

- We use `BufferedInputStream` to buffer input data from a file named "input.txt".
- We use `BufferedOutputStream` to buffer output data to a file named "output.txt".
- Inside the try-with-resources block, we read bytes from the `BufferedInputStream` and write them to the `BufferedOutputStream`.
- The use of buffered streams improves performance by reducing the number of physical I/O operations.


## BufferedReader And Writer
`BufferedReader` and `BufferedWriter` are classes in Java that provide buffering functionality for reading and writing character data, respectively. They are commonly used to improve I/O performance by reducing the number of times data is physically read from or written to the underlying stream.

Here's a brief explanation of each:

1. **BufferedReader**:
   - `BufferedReader` adds buffering capability to a character input stream, such as `FileReader` or `InputStreamReader`.
   - It reads characters from the underlying input stream into an internal buffer and then delivers characters from this buffer to the caller when reading is requested.
   - Reading data from the buffer is faster than reading directly from the input stream because fewer system calls are made to the underlying stream.
   - It provides a more efficient way to read character data, especially when the underlying input stream involves costly operations, such as file or network I/O.

2. **BufferedWriter**:
   - `BufferedWriter` adds buffering capability to a character output stream, such as `FileWriter` or `OutputStreamWriter`.
   - It accumulates output character data into an internal buffer and periodically flushes this buffer to the underlying output stream.
   - Writing data to the buffer is faster than writing directly to the output stream because fewer system calls are made to the underlying stream.
   - It provides a more efficient way to write character data, especially when the underlying output stream involves costly operations, such as file or network I/O.

Here's a basic example demonstrating the use of `BufferedReader` and `BufferedWriter` together:

```java
import java.io.*;

public class BufferedReadWriteExample {
    public static void main(String[] args) {
        try (
            // Create a BufferedReader with FileReader
            BufferedReader reader = new BufferedReader(new FileReader("input.txt"));
            // Create a BufferedWriter with FileWriter
            BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))
        ) {
            String line;
            // Read lines from input file and write them to output file
            while ((line = reader.readLine()) != null) {
                writer.write(line);
                writer.newLine(); // Write a new line character after each line
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

In this example:

- We use `BufferedReader` to buffer character input data from a file named "input.txt".
- We use `BufferedWriter` to buffer character output data to a file named "output.txt".
- Inside the try-with-resources block, we read lines from the `BufferedReader` and write them to the `BufferedWriter`, ensuring that a new line character is written after each line.
- The use of buffered readers and writers improves performance by reducing the number of physical I/O operations.


## Piped Input STream And Output Stream
Piped streams in Java provide a way for two threads to communicate with each other through an in-memory pipe. There are two types of piped streams:

1. **PipedInputStream**: This class represents an input stream for reading data from a piped output stream.
   
2. **PipedOutputStream**: This class represents an output stream for writing data to a piped input stream.

The basic idea is that data written to a `PipedOutputStream` can be read from the associated `PipedInputStream`, and vice versa.

Here's a basic example demonstrating the use of piped streams:

```java
import java.io.*;

public class PipedStreamExample {
    public static void main(String[] args) {
        try {
            // Create piped input and output streams
            PipedInputStream in = new PipedInputStream();
            PipedOutputStream out = new PipedOutputStream();

            // Connect the input and output streams
            in.connect(out);

            // Create writer and reader threads
            Thread writerThread = new Thread(new Writer(out));
            Thread readerThread = new Thread(new Reader(in));

            // Start the threads
            writerThread.start();
            readerThread.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Writer thread class
    static class Writer implements Runnable {
        private final PipedOutputStream out;

        Writer(PipedOutputStream out) {
            this.out = out;
        }

        public void run() {
            try {
                // Write data to the output stream
                String message = "Hello, world!";
                out.write(message.getBytes());
                out.close(); // Close the output stream
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // Reader thread class
    static class Reader implements Runnable {
        private final PipedInputStream in;

        Reader(PipedInputStream in) {
            this.in = in;
        }

        public void run() {
            try {
                // Read data from the input stream
                byte[] buffer = new byte[1024];
                int bytesRead = in.read(buffer);
                String message = new String(buffer, 0, bytesRead);
                System.out.println("Received message: " + message);
                in.close(); // Close the input stream
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

In this example:

- We create a `PipedInputStream` and a `PipedOutputStream`.
- We connect the input stream to the output stream using the `connect()` method.
- We create two threads: one for writing data to the output stream (`Writer` class) and one for reading data from the input stream (`Reader` class).
- The writer thread writes a message ("Hello, world!") to the output stream and then closes it.
- The reader thread reads the message from the input stream and prints it.
- Both the input and output streams are automatically closed when their associated streams are closed.

AnotherExample:
```java

package pipeddemo;

import java.io.*;

class Producer extends Thread
{
    OutputStream os;
    
    public Producer(OutputStream o)
    {
        os=o;
    }
    
    public void run()
    {
        int count=1;
        
        while(true)
        {
            try{
            os.write(count);
            os.flush();
            
            System.out.println("Producer "+count);
            System.out.flush();

            Thread.sleep(10);
            count++;
            }catch(Exception e){}
        }
    }
    
}

class Consumer extends Thread
{
    InputStream is;
    
    public Consumer(InputStream s)
    {
        is=s;
    }
    
    public void run()
    {
        int x;
        
        while(true)
        {
            try{
            
                x=is.read();
            
            System.out.println("Consumer "+x);
            System.out.flush();
            Thread.sleep(10);

            }catch(Exception e){}
        }
    }
    
}



public class PipedDemo 
{
    public static void main(String[] args) throws Exception
    {
       PipedInputStream pis=new PipedInputStream();
       PipedOutputStream pos=new PipedOutputStream();
       
       pos.connect(pis);
       
       Producer p=new Producer(pos);
       Consumer c=new Consumer(pis);
       
       p.start();
       
       c.start();
       
    }  
}
```


## Random Access Files
In Java, random access files are managed using the `RandomAccessFile` class, which is part of the `java.io` package. This class provides methods for reading from and writing to a file at a specific position, allowing for random access to the contents of the file.

Here's a basic overview of how to work with random access files in Java:

1. **Opening a Random Access File**: You can open a random access file in either read-only mode, write-only mode, read-write mode, or read-write mode with the option to create the file if it doesn't exist.

    ```java
    // Open a file named "example.txt" in read-write mode
    RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
    ```

2. **Reading from a Random Access File**: You can move the file pointer to a specific position and read data from that location.

    ```java
    // Move the file pointer to position 10
    file.seek(10);
    
    // Read a byte from the current position
    byte data = file.readByte();
    ```

3. **Writing to a Random Access File**: Similarly, you can move the file pointer to a specific position and write data to that location.

    ```java
    // Move the file pointer to position 20
    file.seek(20);
    
    // Write an integer to the current position
    file.writeInt(123);
    ```

4. **Closing the Random Access File**: It's important to close the `RandomAccessFile` object once you're done with it to release system resources.

    ```java
    file.close();
    ```

Here's a complete example demonstrating how to read and write data to a random access file:

```java
import java.io.*;

public class RandomAccessExample {
    public static void main(String[] args) {
        try {
            // Open a file in read-write mode
            RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
            
            // Write data to the file
            file.writeUTF("Hello, World!");
            
            // Move the file pointer to the beginning
            file.seek(0);
            
            // Read data from the file
            String data = file.readUTF();
            System.out.println("Data read from file: " + data);
            
            // Close the file
            file.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

This example opens a file named "example.txt", writes the string "Hello, World!" to it, then reads the data back and prints it to the console.

Another Example:
```java
package randomaccessdemo;
import java.io.*;

public class RandomAccessDemo 
{
    public static void main(String[] args) throws Exception
    {
        RandomAccessFile rf=new RandomAccessFile("C:\\MyJava\\Data.txt","rw");
       //byte b[]={'A','B','C','D','E','F','G''H','I','J'};
       
        System.out.println((char)rf.read());
        System.out.println((char)rf.read());
        System.out.println((char)rf.read());
        rf.write('d');
        System.out.println((char)rf.read());
        rf.skipBytes(3);
        System.out.println((char)rf.read());
        rf.seek(3);
        System.out.println((char)rf.read());
        System.out.println(rf.getFilePointer());
        rf.seek(rf.getFilePointer()+2);
        System.out.println((char)rf.read());
    }   
}
```


##  File Class
In Java, the `File` class, located in the `java.io` package, represents a file or directory path on the system. It doesn't directly provide methods for reading or writing to files but is instead used for file manipulation operations such as creating, deleting, renaming, and checking file properties.

Here's an overview of some common operations you can perform using the `File` class:

1. **Creating a File Object**: You can create a `File` object representing a file or directory path on the system.

    ```java
    File file = new File("path/to/file.txt");
    ```

2. **Creating a New File**: You can use the `createNewFile()` method to create a new empty file if it doesn't already exist.

    ```java
    if (file.createNewFile()) {
        System.out.println("File created successfully.");
    } else {
        System.out.println("File already exists.");
    }
    ```

3. **Checking File Existence**: You can check whether a file or directory exists using the `exists()` method.

    ```java
    if (file.exists()) {
        System.out.println("File exists.");
    } else {
        System.out.println("File does not exist.");
    }
    ```

4. **Deleting a File**: You can delete a file or directory using the `delete()` method.

    ```java
    if (file.delete()) {
        System.out.println("File deleted successfully.");
    } else {
        System.out.println("Failed to delete file.");
    }
    ```

5. **Getting File Information**: You can retrieve various information about a file or directory, such as its name, path, size, and whether it's a file or directory.

    ```java
    System.out.println("File name: " + file.getName());
    System.out.println("File path: " + file.getPath());
    System.out.println("File size: " + file.length() + " bytes");
    System.out.println("Is directory? " + file.isDirectory());
    ```

6. **Renaming a File**: You can rename a file or directory using the `renameTo()` method.

    ```java
    File newFile = new File("path/to/newFile.txt");
    if (file.renameTo(newFile)) {
        System.out.println("File renamed successfully.");
    } else {
        System.out.println("Failed to rename file.");
    }
    ```

The `File` class is often used in conjunction with other classes such as `FileInputStream`, `FileOutputStream`, `BufferedReader`, and `BufferedWriter` for reading from and writing to files. It provides a convenient way to perform file-related operations in Java applications.

Another Example:
```java
package filehandling;
import java.io.*;

public class FileHandling 
{
    public static void main(String[] args) throws Exception
    {
        // select path of any directory on you computer
       File f=new File("C:\\MyJava");
       
       System.out.println(f.isDirectory());
       File list[]=f.listFiles();
        
       for(File x:list)
       {
           System.out.println(x.getParent()+" "+x.getName());
       }
      
    }
}
```

## Print Stream
In Java, `PrintStream` is a class provided in the `java.io` package that facilitates printing formatted representations of objects to an output stream. It is commonly used to print text data to various destinations such as the console (`System.out`), files, or network sockets.

Here's an overview of how to use `PrintStream`:

1. **Creating a `PrintStream` Object**: You can create a `PrintStream` object by passing an output stream to its constructor.

    ```java
    PrintStream ps = new PrintStream(System.out); // Print to standard output (console)
    ```

2. **Printing Data**: You can use various `print()` and `println()` methods to print data of different types to the output stream.

    ```java
    ps.print("Hello, "); // Prints without a newline
    ps.println("World!"); // Prints with a newline
    ps.printf("Formatted: %d", 42); // Prints formatted string
    ```

3. **Flushing and Closing**: It's a good practice to flush the stream to ensure that all data is written to the destination. The `close()` method is used to close the stream and release associated system resources.

    ```java
    ps.flush(); // Flushes the stream
    ps.close(); // Closes the stream
    ```

4. **Redirecting Output**: You can redirect the output of a `PrintStream` to a file by passing a `FileOutputStream` object to its constructor.

    ```java
    try {
        PrintStream fileStream = new PrintStream(new FileOutputStream("output.txt"));
        fileStream.println("Data written to file.");
        fileStream.close();
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
    ```

5. **Error Output**: `System.err` is a `PrintStream` object that by default prints to the standard error stream, which is typically the console. You can also redirect it to a file or another destination.

    ```java
    PrintStream errStream = System.err;
    errStream.println("An error occurred!");
    ```

6. **Auto-Flush and Encoding**: By default, `PrintStream` automatically flushes the output after every byte written. You can also specify the character encoding when creating a `PrintStream` object.

    ```java
    PrintStream ps = new PrintStream(System.out, true, "UTF-8"); // Auto-flush and UTF-8 encoding
    ```

`PrintStream` provides convenient methods for formatted output and is widely used in Java applications for printing data to various output destinations.

```java

import java.io.*;

class Student
{
    int rollno;
    String name;
    String dept;
}

public class PrintStreamDemo 
{
    public static void main(String[] args) throws Exception
    {
        FileOutputStream fos=new FileOutputStream("C:\\MyJava\\Student1.txt");
        PrintStream ps=new PrintStream(fos);
        
        
        Student s=new Student();
        s.rollno=10;
        s.name="John";
        s.dept="CSE";
        
        ps.println(s.rollno);
        ps.println(s.name);
        ps.println(s.dept);
        
        ps.close();
        fos.close();
        
    }    
}
```


## In Java, data streams are a set of classes in the `java.io` package that provide a convenient way to handle binary I/O operations. They allow reading and writing primitive data types (such as `int`, `double`, `boolean`, etc.) and strings directly to and from streams, without having to manually convert them to and from bytes.

There are two main types of data streams in Java:

1. **DataInputStream**: This class reads primitive data types and strings from an input stream. It provides methods like `readInt()`, `readDouble()`, `readBoolean()`, `readUTF()`, etc., for reading data of specific types.

    ```java
    try (DataInputStream dis = new DataInputStream(new FileInputStream("data.dat"))) {
        int intValue = dis.readInt();
        double doubleValue = dis.readDouble();
        boolean booleanValue = dis.readBoolean();
        String stringValue = dis.readUTF();
        
        System.out.println("Int Value: " + intValue);
        System.out.println("Double Value: " + doubleValue);
        System.out.println("Boolean Value: " + booleanValue);
        System.out.println("String Value: " + stringValue);
    } catch (IOException e) {
        e.printStackTrace();
    }
    ```

2. **DataOutputStream**: This class writes primitive data types and strings to an output stream. It provides methods like `writeInt()`, `writeDouble()`, `writeBoolean()`, `writeUTF()`, etc., for writing data of specific types.

    ```java
    try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.dat"))) {
        dos.writeInt(42);
        dos.writeDouble(3.14);
        dos.writeBoolean(true);
        dos.writeUTF("Hello, World!");
    } catch (IOException e) {
        e.printStackTrace();
    }
    ```

Data streams are useful when you need to read or write primitive data types or strings in a binary format. They handle the conversion between the primitive data types and their byte representation, making it easier to work with binary data in Java applications. However, it's important to note that data streams are not suitable for reading or writing complex objects or structured data; for that, you would typically use object serialization or other techniques.

## Serialisation 
Serialization in Java is a mechanism used to convert an object into a byte stream, which can then be written to a file, sent over a network, or stored in a database. Later, this byte stream can be deserialized back into an object, allowing the object's state to be reconstructed.

Java provides built-in support for serialization through the `java.io.Serializable` interface and the `ObjectInputStream` and `ObjectOutputStream` classes. To make a class serializable, it needs to implement the `Serializable` interface, which is a marker interface with no methods. This interface indicates that the objects of the class can be serialized.

Here's a basic example of serialization and deserialization in Java:

```java
import java.io.*;

// A class that implements Serializable interface
class MyClass implements Serializable {
    private static final long serialVersionUID = 1L; // Unique identifier for the class
    
    // Fields
    private int id;
    private String name;
    
    // Constructor
    public MyClass(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    // Getters and setters
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

public class SerializationExample {
    public static void main(String[] args) {
        // Serialization
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("data.ser"))) {
            MyClass obj = new MyClass(1, "John");
            oos.writeObject(obj); // Serialize object
            System.out.println("Object serialized successfully.");
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // Deserialization
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("data.ser"))) {
            MyClass obj = (MyClass) ois.readObject(); // Deserialize object
            System.out.println("Deserialized Object - Id: " + obj.getId() + ", Name: " + obj.getName());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

In this example, the `MyClass` implements the `Serializable` interface. Objects of this class can be serialized and deserialized. We serialize an instance of `MyClass` to a file named "data.ser" using `ObjectOutputStream`, and then deserialize it back using `ObjectInputStream`. Finally, we print the deserialized object's attributes.

Serialization is commonly used in scenarios such as saving the state of an object, sending objects across a network, or caching objects in a persistent storage medium. However, it's important to note that not all objects should be serialized; for example, objects containing sensitive data or references to resources may not be suitable for serialization. Additionally, serialized objects may not be compatible across different versions of the application if their structure changes.

```java
package objectdemo;
import java.io.*;

class Student implements Serializable
{
    private int rollno;
    private String name;
    private float avg;
    private String dept;
    public static int Data=10;
    public transient int t;
    
    public Student()
    {
        
    }
    public Student(int r,String n,float a,String d)
    {
        rollno=r;
        name=n;
        avg=a;
        dept=d;
        Data=500;
        t=500;
    }
    
    public String toString()
    {
        return "\nStudent Details\n"+
                "\nRoll "+rollno+
                "\nName "+name+
                "\nAverage "+avg+
                "\nDept "+dept+
                "\nData "+Data+
                "\nTransient "+t+"\n";
    }
    
}

public class ObjectDemo 
{
   /* public static void main(String[] args) throws Exception
    {
        FileOutputStream fos=new FileOutputStream("C:\\MyJava\\Student3.txt");
        ObjectOutputStream oos=new ObjectOutputStream(fos);
        
        Student s=new Student(10,"John",89.9f,"CSE");
        
        oos.writeObject(s);
        
        fos.close();
        oos.close();
        
    }
    */
    public static void main(String[] args) throws Exception
    {
        FileInputStream fis=new FileInputStream("C:\\MyJava\\Student3.txt");
        ObjectInputStream ois=new ObjectInputStream(fis);
        
        Student s=(Student)ois.readObject();
        
        System.out.println(s);
        
        fis.close();
        ois.close();
        
    }
}
```